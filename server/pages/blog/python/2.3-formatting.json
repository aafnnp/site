{"pageProps":{"data":{"date":"December 10, 2021","title":"Formatting","tags":["python"],"description":"输出格式化","fromNow":"5 days ago"},"content":{"compiledSource":"var c=Object.defineProperty,l=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,t=Object.prototype.propertyIsEnumerable;var i=(e,a,p)=>a in e?c(e,a,{enumerable:!0,configurable:!0,writable:!0,value:p}):e[a]=p,r=(e,a)=>{for(var p in a||(a={}))s.call(a,p)&&i(e,p,a[p]);if(o)for(var p of o(a))t.call(a,p)&&i(e,p,a[p]);return e},d=(e,a)=>l(e,h(a));var m=(e,a)=>{var p={};for(var n in e)s.call(e,n)&&a.indexOf(n)<0&&(p[n]=e[n]);if(e!=null&&o)for(var n of o(e))a.indexOf(n)<0&&t.call(e,n)&&(p[n]=e[n]);return p};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(p){var n=p,{components:e}=n,a=m(n,[\"components\"]);return mdx(MDXLayout,d(r(r({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"\\u5F53\\u8F93\\u51FA\\u6570\\u636E\\u65F6\\uFF0C\\u6211\\u4EEC\\u5E0C\\u671B\\u80FD\\u591F\\u6309\\u7167\\u4E00\\u5B9A\\u7684\\u683C\\u5F0F\\u8F93\\u51FA\\uFF0C\\u8FD9\\u4E2A\\u65F6\\u5019\\u5C31\\u53EF\\u4EE5\\u4F7F\\u7528 format()\\u51FD\\u6570\\u3002\\u6BD4\\u5982\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`      Name      Shares        Price\n----------  ----------  -----------\n        AA         100        32.20\n       IBM          50        91.10\n       CAT         150        83.44\n      MSFT         200        51.23\n        GE          95        40.37\n      MSFT          50        65.10\n       IBM         100        70.44\n`)),mdx(\"h2\",null,\"\\u5B57\\u7B26\\u8F93\\u51FA\\u683C\\u5F0F\\u5316\"),mdx(\"p\",null,\"\\u5728\",mdx(\"inlineCode\",{parentName:\"p\"},\"python 3.6+\"),\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"f-strings\"),\"\\u683C\\u5F0F\\u5316\\u5B57\\u7B26\\u4E32\\uFF0C\\u5982\\u4E0B\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`name = 'IBM'\nshares = 100\nprice = 91.1\nf'{name:>10s} {shares:>10d} {price:>10.2f}'\n#'       IBM        100      91.10'\n\n# \\u901A\\u5E38\\u914D\\u5408 print()\\u51FD\\u6570\\u4F7F\\u7528\\uFF0C\\u5982\\u4E0B\\uFF1A\nprint(f'{name:>10s} {shares:>10d} {price:>10.2f}')\n`)),mdx(\"h2\",null,\"\\u683C\\u5F0F\\u5316\\u4EE3\\u7801\"),mdx(\"p\",null,\"\\u683C\\u5F0F\\u4EE3\\u7801(\\u5728\",mdx(\"inlineCode\",{parentName:\"p\"},\"{}\"),\"\\u4E2D\",mdx(\"inlineCode\",{parentName:\"p\"},\":\"),\" \\u4E4B\\u540E)\\u7C7B\\u4F3C\\u4E8E c \",mdx(\"inlineCode\",{parentName:\"p\"},\"printf ()\"),\"\\u3002\\u5E38\\u89C1\\u4EE3\\u7801\\u5305\\u62EC:\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`d       # \\u6574\\u6570\nb       # \\u5341\\u516D\\u8FDB\\u5236\nx       # \\u5341\\u516D\\u8FDB\\u5236\nf       # \\u6D6E\\u70B9\\u6570\ne       # \\u6307\\u6570\ng       # \\u6307\\u6570\\u6216\\u6D6E\\u70B9\\u6570\ns       # \\u5B57\\u7B26\\u4E32\nc       # \\u5B57\\u7B26\n`)),mdx(\"p\",null,\"\\u5E38\\u7528\\u7684\\u4FEE\\u9970\\u7B26\\u8C03\\u6574\\u5B57\\u6BB5\\u5BBD\\u5EA6\\u548C\\u5341\\u8FDB\\u5236\\u7CBE\\u5EA6\\u3002\\u8FD9\\u662F\\u4E00\\u4E2A\\u90E8\\u5206\\u5217\\u8868:\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`:>10d   # \\u5BBD\\u5EA6\\u4E3A10\\uFF0C\\u5341\\u8FDB\\u5236\\u7CBE\\u5EA6\\u65E0\\u9650\\u5236\n:<10d   # \\u5BBD\\u5EA6\\u4E3A10\\uFF0C\\u5341\\u8FDB\\u5236\\u7CBE\\u5EA6\\u65E0\\u9650\\u5236\n:^10d   # \\u5BBD\\u5EA6\\u4E3A10\\uFF0C\\u5341\\u8FDB\\u5236\\u7CBE\\u5EA6\\u65E0\\u9650\\u5236\n:0.2f   # \\u5BBD\\u5EA6\\u4E3A\\u65E0\\u9650\\u5236\\uFF0C\\u5341\\u8FDB\\u5236\\u7CBE\\u5EA6\\u4E3A2\n`)),mdx(\"h2\",null,\"\\u5B57\\u5178\\u683C\\u5F0F\\u5316\"),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"format_map\"),\"\\u51FD\\u6570\\u53EF\\u4EE5\\u5C06\\u5B57\\u5178\\u4E2D\\u7684\\u952E\\u548C\\u503C\\u5BF9\\u5E94\\u8F93\\u51FA\\uFF0C\\u5982\\u4E0B\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`s = {\n    'name': 'IBM',\n    'shares': 100,\n    'price': 91.1\n}\n'{name:>10s} {shares:10d} {price:10.2f}'.format_map(s)\n#'       IBM        100      91.10'\n`)),mdx(\"h2\",null,\"format()\\u51FD\\u6570\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`'{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1)\n#'       IBM        100      91.10'\n'{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1)\n#'       IBM        100      91.10'\n`)),mdx(\"h2\",null,\"C \\u8BED\\u8A00\\u683C\\u5F0F\\u5316\"),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"%\"),\"\\u53EF\\u4EE5\\u683C\\u5F0F\\u5316\\u5B57\\u7B26\\u4E32\\uFF0C\\u5982\\u4E0B\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-python\"}),`'The value is %d' % 3\n#'The value is 3'\n'%5d %-5d %10d' % (3,4,5)\n#'    3 4              5'\n'%0.2f' % (3.1415926,)\n#'3.14'\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"December 10, 2021","title":"Formatting","tags":["python"],"description":"输出格式化","fromNow":"5 days ago"}},"randomPost":[{"data":{"date":"April 12, 2018","title":"Flexbox指南","tags":["css"],"description":"Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。","fromNow":"4 years ago"},"content":"\n![Flexbox](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181016105026.png)\n\nFlexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。\n\n- 基本介绍\n- 浏览器兼容性\n- 启用 Flexbox\n- 容器属性\n  - 行||列 对齐 ==row and columns==\n  - 水平||垂直 对齐 ==Vertical and horizontal==\n  - 更改水平对齐 ==change horizontal alignment==\n  - 更改垂直对齐 ==change vertical alignment==\n    - 关于基准线 ==about baseline==\n  - 换行 ==wrap==\n- flex 元素上的属性\n  - order\n  - align-self\n  - flex-grow\n  - flex-shrink\n  - flex-basis\n  - flex\n\n### 介绍\n\nFlexbox，也称为灵活盒模块，是两个现代布局系统之一，还有 CSS Grid。与 CSS Grid（二维）相比，flexbox 是一维布局模型。它将基于行或列控制布局，但不能同时控制布局。flexbox 的主要目标是允许项目填充其容器提供的整个空间，具体取决于您设置的一些规则。Flexbox 不兼容 IE10 以下，IE10 以下可以使用如下方式：\n\n- Table layouts\n- Floats\n- clearfix hacks\n- display: table hacks\n\n### 兼容性\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205051.png)\n\nIE10 以下不兼容，一些浏览器需要使用-webkit 或者 display:-webkit-box 兼容处理。\n\n### 使用 flexbox\n\n```css\ndisplay: flexbox;\n```\n\n或者\n\n```css\ndisplay: inline-flexbox;\n```\n\n### 容器属性\n\n- flex-direction\n- justify-content\n- align-items\n- flex-wrap\n- flex-flow\n\n### 行对齐或者列对齐\n\nflex-direction 决定容器以行对齐还是列对齐。\n\n- flex-direction:row，行对齐，从左到右\n- flex-direction:row-reverse，行对齐，从右到左\n- flex-direction:column，列对齐，从上到下\n- flex-direction:column-reverse，列对齐，从下到上\n\n如下图所示：\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205713.png)\n\n### 水平对齐或者垂直对齐\n\nflex-direction 默认是 row，从左向右，当其属性值为 column 时，是从上到下，可以使用 justify-content 和 align-items 改变水平和垂直对齐。\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100130.png)\n\n### 改变水平对齐方式\n\njustify-content 有 5 个属性值：\n\n1. flex-start 左对齐\n2. flex-end 右对齐\n3. center 居中对齐\n4. space-between 首尾对齐容器左右侧，中间间距相等\n5. space-around 每个元素的间距相等\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100921.png)\n\n### 改变垂直对齐方式\n\nalign-items 有 5 个属性值：\n\n1. flex-start 顶部对齐\n2. flex-end 底部对齐\n3. center 居中对齐\n4. baseline 基线对齐\n5. stretch 拉伸以适应容器\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022141409.png)\n\n关于 align-items:baseline，可以看看 codepen：[https://codepen.io/flaviocopes/pen/oExoJR](https://codepen.io/flaviocopes/pen/oExoJR)\n\n### 换行\n\n默认情况下，flexbox 容器中的项目保留在一行中，缩小它们以适合容器。\n\n可以使用 flex-wrap:wrap 或者 flex-wrap:wrap-reverse 对容器中的元素进行换行处理。\n\n一种简写方式：flex-flow:row wrap;即 flex-direction:row && flex-wrap:wrap\n\n### 适用于 flexbox 容器内每个元素的属性\n\n1. order\n2. align-self\n3. flex-grow\n4. flex-shrink\n5. flex-basis\n6. flex\n\n#### order-改变元素的顺序，如下图所示，可以指定某个元素的 order 值，以改变其位置，默认值为 0\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142507.png)\n\n#### align-self-元素使用 align-self 覆盖容器的 align-items 对当前元素的对齐方式\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142842.png)\n\n#### flex-grow || flex-shrink 如有必要，可以增加或缩小某个元素\n\nflex-grow：默认值为 0，当某个元素 flex-grow 为 1，另一个为 2，则为 flex-grow：2 的元素占用 flex-grow:1 的空间的 2 倍。\n\nflex-shrink：默认值为 1，如果没有显示定义该属性，将会自动按照默认值 1 在所有因子相加之后计算比率来进行空间收缩。\n\n比如：有这么一个容器，div>.box1*3+.box2*2 父容器定义宽度为 500px，子元素定义宽度为 120px，box1 的 flex-shrink 为 1，.box2 的 flex-shrink 为 2，那么子项相加之后即为 600 px，超出父容器 100px。那么超出的 100px 需要被 A、B、C、D、E 消化 通过收缩因子，所以加权综合可得 100*1+100*1+100*1+100*2+100\\*2=700px。\n\n```\n于是我们可以计算 A、B、C、D、E 将被移除的溢出量是多少：\nA 被移除溢出量：(100*1/700)*100，即约等于14px\nB 被移除溢出量：(100*1/700)*100，即约等于14px\nC 被移除溢出量：(100*1/700)*100，即约等于14px\nD 被移除溢出量：(100*2/700)*100，即约等于28px\nE 被移除溢出量：(100*2/700)*100，即约等于28px\n\n最后A、B、C、D、E的实际宽度分别为：120-14=106px, 120-14=106px, 120-14=106px, 120-28=92px,120-28=92px\n```\n\n#### flex-basis-用于设置或检索弹性盒伸缩基准值，默认值为 auto，其与 width 的区别可以参考这篇文章：https://www.jianshu.com/p/17b1b445ecd4\n\n#### flex：有三个属性值\n\n1. flex-grow\n2. flex-shrink\n3. flex-basis\n\n```css\nflex: 0 1 auto 分别对应flex-grow、flex-shrink、flex-basis;\n```\n\n## 结尾\n\n友情献上小游戏，通过游戏学习 flexbox\n\nhttp://flexboxfroggy.com/#zh-cn\n","slug":"css/Flexbox指南"},{"data":{"date":"May 19, 2020","title":"闭包","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 什么是闭包\n\n作用：能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。\n\n原理：基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到\n\n```javascript\nfunction foo() {\n  var a = 'hzfe';\n  function bar() {\n    console.log(a);\n  }\n  return bar;\n}\n\nvar baz = foo();\nbaz(); // hzfe\n```\n\n在这个例子中，函数 bar 作为返回值返回后，在自己定义的词法作用域以外的地方执行。一般来说，在函数 foo 执行后，通常会期待函数 foo 的整个内部作用域被引擎回收机制销毁。而闭包可以阻止这件事情的发生。事实上内部作用域依然存在，因为函数 bar 本身在使用，所以并不会被回收。\n\n在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n## 闭包的应用\n\n无论何时何地，如果将函数作为返回值，就会看到闭包在这些函数中的应用。在定时器，事件监听器，ajax 请求，跨窗口通信，web workers 或者任何其他的异步/同步任务中，只要使用了回调函数，实际上就是使用闭包。使用闭包的例子可以参考实现节流防抖函数。\n\n```javascript\nvar a = 'hzfe';\n(function IIFE() {\n  console.log(a);\n})();\n```\n\n通常认为立即执行函数（IIFE）是典型的观察闭包的典型例子，但严格来说并不是。虽然创建了闭包，但没有体现出闭包的作用。因为函数并不是在它本身的词法作用域以外执行的。 它在定义时所在的作用域中执行，而非外部作用域。\n\n## 扩展\n\n- [闭包 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)\n- [垃圾回收机制](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Closed_Overlay_Requires_Arguments)\n- [你不知道的 JavaScript](https://www.imooc.com/article/2907)\n","slug":"javascript/advance/闭包"},{"data":{"date":"January 14, 2021","title":"21个用于日常开发的有用JavaScript片段","tags":["i18n","javascript"],"fromNow":"a year ago"},"content":"\n## 输入值数字化\n\n```javascript\nconst checkMyValueType = (event) => {\n  console.log(typeof event.target.value); // string\n  console.log(typeof event.target.valueAsNumber); // number\n};\n<input type=\"number\" onkeyup=\"checkMyValueType(event)\" />;\n```\n\n## 复制输入框值到粘贴板\n\n```javascript\nfunction copyToClipboard(inputID) {\n  navigator.clipboard.writeText(document.querySelector(inputID).value);\n}\n```\n\n## 检查窗口是否可见\n\n```javascript\nconst isBrowserTabInView = () => document.hidden;\nisBrowserTabInView(); // returns true or false depending if tab is in view / focus\n```\n\n## 布尔值取反\n\n```javascript\nlet myBool = false;\nmyBool = !myBool;\nconsole.log(myBool); // true\nmyBool = !myBool;\nconsole.log(myBool); // false\n```\n\n## 检查值是否是偶数\n\n```javascript\nconst isEven = (num) => num % 2 === 0;\nconsole.log(isEven(2)); // true\nconsole.log(isEven(3)); // false\n```\n\n## 检查日期是否是工作日\n\n```javascript\nconst isWeekday = (d) => d.getDay() % 6 !== 0;\nconsole.log(isWeekday(new Date(2021, 0, 11))); // true (Monday)\nconsole.log(isWeekday(new Date(2021, 0, 10))); // false (Sunday)\n```\n\n## 日期加减\n\n```javascript\nconst addDaysToDate = (date, n) => {\n  date.setDate(date.getDate() + n);\n  return date.toISOString().split('T')[0];\n};\naddDaysToDate('2021-0-10', 10); // \"2021-01-20\"\naddDaysToDate('2021-0-10', -10); // '2020-12-31'\n```\n\n## 获取时分秒\n\n```javascript\nconst timeFromDate = (date) => date.toTimeString().slice(0, 8);\nconsole.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0)));\n// \"17:30:00\"\nconsole.log(timeFromDate(new Date(2021, 0, 10, 5, 56, 44)));\n// \"05:56:44\"\n```\n\n## 计算两个日期之间的工作日数\n\n````javascript\nconst countWeekDaysBetween = (startDate, endDate) =>\n  Array\n    .from({ length: (endDate - startDate) / (1000 * 3600 * 24) })\n    .reduce(count => {\n      if (startDate.getDay() % 6 !== 0) {\n        count++;\n      }\n     startDate = new Date(startDate.setDate(startDate.getDate() + 1));\n      return count;\n    }, 0);\ncountWeekDaysBetween(new Date(2021, 0, 10), new Date(2021, 0, 20)); // 7\ncountWeekDaysBetween(new Date(2021, 1, 10), new Date(2021, 2, 18)); // 26\n`## 检查localstorage是否可用\n``` javascript\nconst isLocalStorageEnabled = () => {\n  try {\n    const key = `__storage__test`;\n    window.localStorage.setItem(key, null);\n    window.localStorage.removeItem(key);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nisLocalStorageEnabled(); // true, if localStorage is accessible\n````\n\n## 计算函数等花费时间\n\n```javascript\nstartTime = performance.now();\nanyMethodOrCode();\nconst endTime = performance.now();\nconsole.log(endTime - startTime + ' milliseconds.'); // (Time in milliseconds)\n```\n\n## 捕获右键点击\n\n```javascript\nwindow.oncontextmenu = () => {\n  console.log('right click');\n};\n```\n\n## 只触发一次事件\n\n```javascript\nconst myButton = document.getElementById('myBtn');\nconst myClickFunction = () => {\n  console.log('this click will only get called once');\n};\nmyButton.addEventListener('click', myClickHandler, {\n  once: true,\n});\n```\n\n## 滚动到顶部\n\n```javascript\nconst scrollToTopOfDocument = () => {\n  const c = document.documentElement.scrollTop || document.body.scrollTop;\n  if (c > 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, c - c / 8);\n  }\n};\nscrollToTopOfDocument();\n```\n\n## 检查字符串是否大写\n\n```javascript\nconst isUpperCase = (str) => str === str.toUpperCase();\nconsole.log(isUpperCase('string')); // false\nconsole.log(isUpperCase('STRING')); // true\nconsole.log(isUpperCase('5TR1NG')); // true\n```\n\n## 检查元素是否处于 focus 状态\n\n```javascript\nconst elementIsInFocus = (el) => el === document.activeElement;\nelementIsInFocus(anyElement); // returns true if in focus, false if not in focus\n```\n\n## 查找数组间不同元素\n\n```javascript\nconst differenceInArrays = (array1, array2) => {\n  const set = new Set(array2);\n  return array1.filter((x) => !set.has(x));\n};\ndifferenceInArrays(['apple', 'orange', 'banana'], ['apple', 'orange', 'mango']); // [\"banana\"]\ndifferenceInArrays([10, 12, 5], [66, 10, 6]); // [12, 5]\n```\n\n## 移除事件监听\n\n```javascript\nconst removeEventOffElement = (el, evt, fn, opts = false) =>\n  el.removeEventListener(evt, fn, opts);\nconst testFunction = () => console.log('My function has been called');\ndocument.body.addEventListener('click', testFunction);\n// Call remove method\nremoveEventOffElement(document.body, 'click', fn);\n```\n\n## 随机生成 HEX 值\n\n```javascript\nconst generateRandomColour = () =>\n  '#' + Math.floor(Math.random() * 16777215).toString(16);\n//EXAMPLE\ndocument.getElementsByTagName('body')[0].style.color = generateRandomColour();\n```\n\n## 查找第一个定义的非空参数\n\n```javascript\nconst getFirstValidValue = (...values) => values.find(v => ![undefined, null].includes(v));\nconsole.log(getFirstValidValue(null, undefined, 'Hey', null); // 'Hey'\n```\n\n## 元素外部监听事件\n\n```javascript\nconst onClickOutsideElement = (element, callback) => {\n  document.addEventListener('click', (e) => {\n    if (!element.contains(e.target)) callback();\n  });\n};\nonClickOutside('#some-element', () => console.log('Hey you missed'));\n// Will log \"Hey you missed\" everytime a click that was not \"some-element\" was clicked\n```\n\n## 总结\n\n有时开发人员会发现自己在一次又一次地创建相同的东西，希望上面的一些代码片段可以在在开发中重用。最新的 JavaScript 特性和浏览器 api 是很重要的。\n","slug":"translate/21个用于日常开发的有用JavaScript片段"},{"data":{"date":"October 28, 2020","title":"Linux命令traceroute","tags":["linux"],"description":"traceroute命令用于显示数据包到主机之间的路径","fromNow":"a year ago"},"content":"\n**traceroute**命令用于显示数据包到主机之间的路径。\n\n> raceroute 命令 用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。\n>\n> 通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。\n>\n> traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其 ip 地址。\n\n## 使用方法\n\n```shell\ntraceroute <host>\n```\n\n## 案例\n\n![1EOlsJ](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/1EOlsJ.png)\n\n## 参数\n\n- -d 使用 Socket 层级的排错功能。\n- -f<存活数值> 设置第一个检测数据包的存活数值 TTL 的大小。\n- -F 设置勿离断位。\n- -g<网关> 设置来源路由网关，最多可设置 8 个。\n- -i<网络界面> 使用指定的网络界面送出数据包。\n- -I 使用 ICMP 回应取代 UDP 资料信息。\n- -m<存活数值> 设置检测数据包的最大存活数值 TTL 的大小。\n- -n 直接使用 IP 地址而非主机名称。\n- -p<通信端口> 设置 UDP 传输协议的通信端口。\n- -r 忽略普通的 Routing Table，直接将数据包送到远端主机上。\n- -s<来源地址> 设置本地主机送出数据包的 IP 地址。\n- -t<服务类型> 设置检测数据包的 TOS 数值。\n- -v 详细显示指令的执行过程。\n- -w<超时秒数> 设置等待远端主机回报的时间。\n- -x 开启或关闭数据包的正确性检验。\n\n**traceroute**命令可在 Linux、macOS、WSL 和任何 UNIX 环境下运行\n","slug":"linux/Linux命令-traceroute"},{"data":{"date":"April 1, 2021","title":"基本类型与引用类型","tags":["javascript"],"fromNow":"8 months ago"},"content":"\n在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。\n\n- 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。\n- 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。\n\n## 基本类型\n\n- Number：`typeof instance === \"number\"`\n- Boolean：`typeof instance === \"boolean\"`\n- String：`typeof instance === \"string\"`\n- Symbol：`typeof instance === \"symbol\"`\n- Null：`typeof instance === \"object\"`\n- Undefined：`typeof instance === \"undefined\"`\n\n```javascript\nconst number = 10;\n\nconst bool = false;\n\nconst str = 'Hello!';\n\nconst missingObject = null;\n\nconst nothing = undefined;\n```\n\n![fZKmxT](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/fZKmxT.jpg)\n\n如果给一个变量赋值一个原始类型值，我们可以认为该变量包含这个原始值。当使用 = 将该变量赋值给其他变量值，其实是将值拷贝了一份并赋值给新的变量，因此原始值是通过值的拷贝来赋值的。\n\n```javascript\nlet a = 1;\nlet b = a;\n\nb = b + 2;\n\nconsole.log(a); // 1\nconsole.log(b); // 3\n```\n\n## 引用类型\n\n- Object：`typeof instance === \"object\"`\n- Array：`typeof instance === \"array\"`\n- Function：`typeof instance === \"function\"`\n\n```javascript\n// Objects\nconst plainObject = {\n  prop: 'Value',\n};\n\nconst array = [1, 5, 6];\n\nconst functionObject = (n1, n2) => {\n  return n1 + n2;\n};\n```\n\n![GLC3Zu](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/GLC3Zu.jpg)\n\n将一个非原始值赋值给一个变量，相当于给这个变量赋值了一个引用类型的值，这个引用执行对象在内存中的地址，而这个变量实际上并不包含这个值。\n\n当一个引用类型，比如一个对象，使用 = 将其赋值给另一个变量，实际上是代表那个对象的地址引用赋值给了新的变量，就和是原始值的拷贝一样\n\n```javascript\nlet x = [1];\nlet y = x;\n\ny.push(2);\n\nconsole.log(x); // [1, 2]\nconsole.log(y); // [1, 2]\n```\n\n> **任何非基本类型的都是对象**\n\n## 比较对象\n\n原始值按值比较，引用值按引用比较\n\n```javascript\n// 原始值比较\nconst one = 1;\nconst oneCopy = 1;\n\nconsole.log(one === oneCopy); // true\nconsole.log(one === 1); // true\nconsole.log(one === one); // true\n\n// 引用值比较\nconst ar1 = [1];\nconst ar2 = [1];\n\nconsole.log(ar1 === ar2); // false\nconsole.log(ar1 === [1]); // false\n\nconst ar11 = ar1;\nconsole.log(ar1 === ar11); // true\nconsole.log(ar1 === ar1); // true\n```\n\n## 总结\n\n原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。\n\n引用值是把引用变量的名称储存在栈中，但是把其实际对象储存在堆中，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若不是通过方法而是通过重新赋值，此时，相当于重新开了一个房间，该值的原指针改变，则另外一个值不会随他的改变而改变\n","slug":"javascript/advance/基本类型与引用类型"},{"data":{"date":"May 19, 2020","title":"理解函数的执行过程","tags":["javascript"],"fromNow":"2 years ago"},"content":"","slug":"javascript/advance/理解函数的执行过程"}]},"__N_SSG":true}