{"pageProps":{"data":{"date":"November 26, 2021","title":"Lists","tags":["python"],"description":"列表（List）是 python 的基本类型","fromNow":"19 days ago"},"content":{"compiledSource":"var i=Object.defineProperty,c=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,m=Object.prototype.propertyIsEnumerable;var t=(e,a,p)=>a in e?i(e,a,{enumerable:!0,configurable:!0,writable:!0,value:p}):e[a]=p,n=(e,a)=>{for(var p in a||(a={}))s.call(a,p)&&t(e,p,a[p]);if(r)for(var p of r(a))m.call(a,p)&&t(e,p,a[p]);return e},l=(e,a)=>c(e,N(a));var d=(e,a)=>{var p={};for(var o in e)s.call(e,o)&&a.indexOf(o)<0&&(p[o]=e[o]);if(e!=null&&r)for(var o of r(e))a.indexOf(o)<0&&m.call(e,o)&&(p[o]=e[o]);return p};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(p){var o=p,{components:e}=o,a=d(o,[\"components\"]);return mdx(MDXLayout,l(n(n({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"\\u521B\\u5EFA\\u5217\\u8868\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names = ['Michael', 'Bob', 'Tracy']\nnums = [1, 2, 3]\n`)),mdx(\"p\",null,\"\\u4E5F\\u53EF\\u4EE5\\u4F7F\\u7528\\u5176\\u4ED6\\u65B9\\u6CD5\",mdx(\"inlineCode\",{parentName:\"p\"},\"split()\"),\"\\u521B\\u5EFA\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`line = 'Hello World!'\nrow = line.split(' ')\nrow # ['Hello', 'World!']\n`)),mdx(\"h2\",null,\"\\u5217\\u8868\\u64CD\\u4F5C\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names.append('Adam') # \\u5728\\u672B\\u5C3E\\u6DFB\\u52A0\\u5143\\u7D20\nnames.insert(1, 'Jack') # \\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u6DFB\\u52A0\\u5143\\u7D20\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"+\"),\"\\u8FDE\\u63A5\\u4E24\\u4E2A\\u5217\\u8868\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`s=[1,2,3]\nt=[4,5,6]\ns+t # [1,2,3,4,5,6]\n`)),mdx(\"p\",null,\"\\u5217\\u8868\\u7D22\\u5F15\\u4ECE 0 \\u5F00\\u59CB\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names = ['Michael', 'Bob', 'Tracy']\nnames[0] # Michael\nnames[1] # Bob\nnames[-1] # Tracy\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528\\u7D22\\u5F15\\u8986\\u76D6\\u5143\\u7D20\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names[0] = 'Adam' # \\u4FEE\\u6539\\u7B2C\\u4E00\\u4E2A\\u5143\\u7D20\nnames # ['Adam', 'Bob', 'Tracy']\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"len\"),\"\\u83B7\\u53D6\\u5217\\u8868\\u957F\\u5EA6\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`len(names) # 3\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"in\"),\"\\u5224\\u65AD\\u5143\\u7D20\\u662F\\u5426\\u5728\\u5217\\u8868\\u4E2D\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`'Adam' in names # True\n'manon' in names # False\n`)),mdx(\"h2\",null,\"\\u5217\\u8868\\u7684\\u5FAA\\u73AF\"),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"for\"),\"\\u5FAA\\u73AF\\u904D\\u5386\\u5217\\u8868\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`for name in names:\n    print(name)\n`)),mdx(\"p\",null,\"\\u67E5\\u627E\\u7D22\\u5F15\\u503C\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names.index('Bob') # 1\n`)),mdx(\"h2\",null,\"\\u79FB\\u9664\\u5143\\u7D20\"),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"del\"),\"\\u6216\",mdx(\"inlineCode\",{parentName:\"p\"},\"remove\"),\"\\u5220\\u9664\\u5143\\u7D20\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`names.remove('Bob') # \\u5220\\u9664\\u7B2C\\u4E00\\u4E2A Bob\ndel names[0] # \\u5220\\u9664\\u7B2C\\u4E00\\u4E2A\\u5143\\u7D20\n`)),mdx(\"h2\",null,\"\\u5217\\u8868\\u7684\\u6392\\u5E8F\"),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"sort\"),\"\\u5BF9\\u5217\\u8868\\u8FDB\\u884C\\u6392\\u5E8F\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`s = [10, 1, 7, 3]\ns.sort()                    # [1, 3, 7, 10]\n\n# Reverse order\ns = [10, 1, 7, 3]\ns.sort(reverse=True)        # [10, 7, 3, 1]\n\n# It works with any ordered data\ns = ['foo', 'bar', 'spam']\ns.sort()                    # ['bar', 'foo', 'spam']\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"sorted\"),\"\\u521B\\u5EFA\\u65B0\\u7684\\u5217\\u8868\\uFF0C\\u4E0D\\u4F1A\\u4FEE\\u6539\\u539F\\u5217\\u8868\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-python\"}),`t = sorted(s)\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"November 26, 2021","title":"Lists","tags":["python"],"description":"列表（List）是 python 的基本类型","fromNow":"19 days ago"}},"randomPost":[{"data":{"date":"May 9, 2018","title":"String","tags":["javascript"],"fromNow":"4 years ago"},"content":"\n## String\n\n### 方法\n\n- String.fromCharCode() //通过一串 Unicode 创建字符串。\n- String.fromCodePoint() //通过一串 码点 创建字符串。\n- String.raw() //通过模板字符串创建字符串。\n\n### 实例方法\n\n- charAt(i)\n- charCodeAt(i)\n- codePointAt(i)\n- concat(str)\n- endsWith(str)\n- includes(str)\n- indexOf(str)\n- lastIndexOf(str)\n- localeCompare()\n- match(regex)\n- normalize()\n- padEnd()\n- padStart()\n- repeat()\n- replace(str1, str2)\n- search(str)\n- slice(begin, end)\n- split(separator)\n- startsWith(str)\n- substring()\n- toLocaleLowerCase()\n- toLocaleUpperCase()\n- toLowerCase()\n- toString()\n- toUpperCase()\n- trim()\n- trimEnd()\n- trimStart()\n- valueOf()\n\n### charAt\n\n> 返回指定位置的字符,且返回的字符长度为 1，**_js 没有一种有别于字符串类型的字符数据类型_**\n\n```javascript\nstring.charAt(index);\n\n'porhub'.charAt(0); //'p'\n'porhub'.charAt(1); //'o'\n'porhub'.charAt(2); //'r'\n```\n\n### charCodeAt\n\n> 返回在指定的位置的字符的 Unicode 编码\n\n**字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN。**\n\n```javascript\nstring.charCodeAt(index);\n\n'porhub'.charCodeAt(0); //112\n'porhub'.charCodeAt(1); //111\n'porhub'.charCodeAt(2); //114\n```\n\n### codePointAt\n\n> ES2015 引入的，用于处理 2 UTF-16 字符的，比如中文，在 ES2015 之前 charCodeAt 只能处理单个字符，处理双字符必须一个个处理然后拼接。\n\n```javascript\nstring.codePointAt(index);\n\n//ES2015之前\n'𠮷'.charCodeAt(0).toString(16); //d842\n'𠮷'.charCodeAt(1).toString(16); //dfb7\n('\\ud842\\udfb7'); //𠮷\n\n//ES2015\n'𠮷'.codePointAt(0); //20bb7\n('\\u{20bb7}'); //𠮷\n```\n\n### concat\n\n> 类似 Array 的 concat\n\n```javascript\nstringObject.concat(stringX,stringX,...,stringX)\n\n\"browser\".concat(\"porhub\");\n```\n\n通常使用 + 拼接来得更方便，或者使用 ES2015 的``字符扩展。\n\n### endWith\n\n> 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。\n\n```javascript\nstr.endsWith(searchString, position);\n\n'JavaScript'.endsWith('Script'); //true\n'JavaScript'.endsWith('script'); //false\n'JavaScript'.endsWith('Script', 5); //false\n'JavaScript'.endsWith('as', 5); //true\n```\n\n### includes\n\n> 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false\n\n```javascript\nstr.includes(searchString, position);\n\n'JavaScript'.includes('Script'); //true\n'JavaScript'.includes('script'); //false\n'JavaScript'.includes('nice'); //true\n'JavaScript'.includes('nice', 3); //false\n```\n\n### indexOf\n\n> 用于返回字符串中出现某个字符的初始位置，如果没有找到，返回-1.\n\n```javascript\nstr.indexOf(searchString, startPosition);\n\n'JavaScript'.indexOf('a'); //1\n'JavaScript'.indexOf('a', 2); //3\n```\n\n### lastIndexOf\n\n> 用于返回某个字符最后出现的位置，如果没有，返回-1\n\n```javascript\nstr.lastIndexOf(searchString, startPosition);\n\n'JavaScript'.lastIndexOf('a'); //3\n'JavaScript'.lastIndexOf('a', 1); //1\n```\n\n### padEnd\n\n> 用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n\n```javascript\nstr.padEnd(targetLength, string);\n\n'abc'.padEnd(10); // \"abc       \"\n'abc'.padEnd(10, 'foo'); // \"abcfoofoof\"\n'abc'.padEnd(6, '123456'); // \"abc123\"\n'abc'.padEnd(1); // \"abc\"\n```\n\n### padStart\n\n> 用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的\n\n```javascript\nstr.padStart(targetLength, string);\n\n'abc'.padStart(10); // \"       abc\"\n'abc'.padStart(10, 'foo'); // \"foofoofabc\"\n'abc'.padStart(6, '123465'); // \"123abc\"\n'abc'.padStart(8, '0'); // \"00000abc\"\n'abc'.padStart(1); // \"abc\"\n```\n\n### repeat\n\n> 构造并返回一个包含被连接在一起的指定数量的新字符串。\n\n```javascript\nstr.repeat(count);\n\n'abc'.repeat(-1); // RangeError: repeat count must be positive and less than inifinity\n'abc'.repeat(0); // \"\"\n'abc'.repeat(1); // \"abc\"\n'abc'.repeat(2); // \"abcabc\"\n'abc'.repeat(3.5); // \"abcabcabc\" 参数count将会被自动转换成整数.\n'abc'.repeat(1 / 0); // RangeError: repeat count must be positive and less than inifinity\n```\n\n### slice\n\n> 截取字符串的一部分，并返回一个新的字符串\n\n```javascript\nstr.slice(startPosition, endPosition);\n\n'abc'.slice(0, 1); //a\n'abc'.slice(0, -1); //ab\n```\n\n### split\n\n> 将字符串切割成数组\n\n```javascript\nstr.split(separator, limit);\n\n'abc'.split(); //\"[a,b,c]\";\n'a,b,c'.split(',', 1); //[a]\n```\n\n### startWith\n\n> 判断字符串是否以给定的字符串开始，返回 true/false\n\n```javascript\nstr.startsWith(searchString, poistion);\n\n'abc'.startsWith('a'); //true\n'abc'.startsWith('a', 1); //false\n```\n\n### substring\n\n> 根据开始索引到结束索引截取字符串\n\n```javascript\nstr.substring(startPosition, endPosition);\n\n'abc'.substring(0, 1); //a\n'abc'.substring(-1); //abc\n```\n\n1. 如果 startPosition 等于 indexEnd，substring 返回一个空字符串。\n2. 如果省略 indexEnd，substring 提取字符一直到字符串末尾。\n3. 如果任一参数小于 0 或为 NaN，则被当作 0。\n4. 如果任一参数大于 stringName.length，则被当作 stringName.length。\n5. 如果 startPosition 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。见下面的例子。\n\n### toLocaleLowerCase/toLocaleUpperCase/toUpperCase/toLowerCase\n\n> 将字符串转换成小写/大写\n\n```javascript\nstr.toLocaleLowerCase() /\n  str.toLocaleUpperCase() /\n  str.toUpperCase() /\n  str.toLowerCase();\n\n'ABC'.toLocaleLowerCase(); //abc\n'abc'.toLocaleUpperCase(); //ABC\n```\n\n### toString\n\n> 将\\*转换成字符串\n\n```javascript\nvar x = new String('Hello world');\n\nalert(x.toString()); // 输出 \"Hello world\"\n```\n\n### trim/trimStart/trimEnd\n\n> 移除空白字符/起始位置空白字符/结尾位置空白字符\n\n```javascript\nstr.trim() / str.trimStart() / str.trimEnd();\n\n'Testing'.trim(); //'Testing'\n' Testing'.trim(); //'Testing'\n' Testing '.trim(); //'Testing'\n'Testing '.trim(); //'Testing'\n```\n\n### valueOf\n\n> 返回 str 的原始值，等同于 String.prototype.toString\n\n```javascript\nstr.valueOf();\n\nx = new String('Hello world');\nalert(x.valueOf()); // Displays \"Hello world\"\n```\n\n### 扩展学习\n\n```javascript\n1 +\n  '5'[(1, 3, 5)] + //\"15\"\n  1; //\"1,3,51\"\n10 + true; // 11\n15 + {}; // \"15[object Object]\"\n8 + null; // 8\n'queen' + null; // \"queennull\"\n12 + undefined; // NaN\n```\n\n[See examples in jsbin](http://jsbin.com/fiwemir/2/edit?js,console)\n","slug":"javascript/base/String"},{"data":{"date":"May 19, 2020","title":"闭包","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 什么是闭包\n\n作用：能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。\n\n原理：基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到\n\n```javascript\nfunction foo() {\n  var a = 'hzfe';\n  function bar() {\n    console.log(a);\n  }\n  return bar;\n}\n\nvar baz = foo();\nbaz(); // hzfe\n```\n\n在这个例子中，函数 bar 作为返回值返回后，在自己定义的词法作用域以外的地方执行。一般来说，在函数 foo 执行后，通常会期待函数 foo 的整个内部作用域被引擎回收机制销毁。而闭包可以阻止这件事情的发生。事实上内部作用域依然存在，因为函数 bar 本身在使用，所以并不会被回收。\n\n在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n## 闭包的应用\n\n无论何时何地，如果将函数作为返回值，就会看到闭包在这些函数中的应用。在定时器，事件监听器，ajax 请求，跨窗口通信，web workers 或者任何其他的异步/同步任务中，只要使用了回调函数，实际上就是使用闭包。使用闭包的例子可以参考实现节流防抖函数。\n\n```javascript\nvar a = 'hzfe';\n(function IIFE() {\n  console.log(a);\n})();\n```\n\n通常认为立即执行函数（IIFE）是典型的观察闭包的典型例子，但严格来说并不是。虽然创建了闭包，但没有体现出闭包的作用。因为函数并不是在它本身的词法作用域以外执行的。 它在定义时所在的作用域中执行，而非外部作用域。\n\n## 扩展\n\n- [闭包 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)\n- [垃圾回收机制](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Closed_Overlay_Requires_Arguments)\n- [你不知道的 JavaScript](https://www.imooc.com/article/2907)\n","slug":"javascript/advance/闭包"},{"data":{"date":"May 7, 2018","title":"Undefined","tags":["javascript"],"fromNow":"4 years ago"},"content":"\nUndefined 类型只有一个值-undefined，即声明变量但未赋值，这个变量的值就是 undefined。\n\n```javascript\nvar a;\nconsole.log(a == undefined); //true\nconsole.log(typeof a); //\"undefined\"\n```\n\n> 对未初始化的变量和未声明的变量执行 typeof 都会返回 undefined\n","slug":"javascript/base/Undefined"},{"data":{"date":"December 21, 2020","title":"Docker images","description":"Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器","tags":["docker"],"fromNow":"a year ago"},"content":"\nDocker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n\nimage 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。\n\n```shell\n# 列出本机的所有 image 文件。\n$ docker image ls\n\n# 删除 image 文件\n$ docker image rm [imageName]\n```\n\nimage 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。\n\n为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。\n\n## 更多\n","slug":"docker/Docker镜像"},{"data":{"date":"December 10, 2021","title":"Formatting","tags":["python"],"description":"输出格式化","fromNow":"5 days ago"},"content":"\n当输出数据时，我们希望能够按照一定的格式输出，这个时候就可以使用 format()函数。比如：\n\n```python\n      Name      Shares        Price\n----------  ----------  -----------\n        AA         100        32.20\n       IBM          50        91.10\n       CAT         150        83.44\n      MSFT         200        51.23\n        GE          95        40.37\n      MSFT          50        65.10\n       IBM         100        70.44\n```\n\n## 字符输出格式化\n\n在`python 3.6+`使用`f-strings`格式化字符串，如下：\n\n```python\nname = 'IBM'\nshares = 100\nprice = 91.1\nf'{name:>10s} {shares:>10d} {price:>10.2f}'\n#'       IBM        100      91.10'\n\n# 通常配合 print()函数使用，如下：\nprint(f'{name:>10s} {shares:>10d} {price:>10.2f}')\n```\n\n## 格式化代码\n\n格式代码(在`{}`中`:` 之后)类似于 c `printf ()`。常见代码包括:\n\n```python\nd       # 整数\nb       # 十六进制\nx       # 十六进制\nf       # 浮点数\ne       # 指数\ng       # 指数或浮点数\ns       # 字符串\nc       # 字符\n```\n\n常用的修饰符调整字段宽度和十进制精度。这是一个部分列表:\n\n```python\n:>10d   # 宽度为10，十进制精度无限制\n:<10d   # 宽度为10，十进制精度无限制\n:^10d   # 宽度为10，十进制精度无限制\n:0.2f   # 宽度为无限制，十进制精度为2\n```\n\n## 字典格式化\n\n使用`format_map`函数可以将字典中的键和值对应输出，如下：\n\n```python\ns = {\n    'name': 'IBM',\n    'shares': 100,\n    'price': 91.1\n}\n'{name:>10s} {shares:10d} {price:10.2f}'.format_map(s)\n#'       IBM        100      91.10'\n```\n\n## format()函数\n\n```python\n'{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1)\n#'       IBM        100      91.10'\n'{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1)\n#'       IBM        100      91.10'\n```\n\n## C 语言格式化\n\n使用`%`可以格式化字符串，如下：\n\n```python\n'The value is %d' % 3\n#'The value is 3'\n'%5d %-5d %10d' % (3,4,5)\n#'    3 4              5'\n'%0.2f' % (3.1415926,)\n#'3.14'\n```\n","slug":"python/2.3-formatting"},{"data":{"date":"April 3, 2021","title":"数组、字典、集合、枚举","tags":["swift"],"description":"取得成功的秘诀就是开始","fromNow":"8 months ago"},"content":"\nSwift 中复杂类型包括：\n\n- Array\n- Set\n- Tuple\n- Dictionary\n- Enums\n\n### Array\n\n> Swift 数组允许您存储相同类型的值，可以使用该值在数组中的位置来检索这些值。Swift 会强制检测元素类型，如果类型不同，会报错。\n\n```swift\n// 创建数组\nvar firstArray = [\"hello\",\"hello\",\"world\"]\nvar secondArray = [\"swift\",\"niubility\"]\n\n// 获取数组第一个元素\nprint(firstArray[0]) // hello\n\n//添加数组\nfirstArray.append(\"manon\")\nfirstArray+=[\"icu\"]\n\n// 循环数组\nfor item in firstArray{\n\tprint(item) //hell hello world manon icu\n}\n\n// 修改数组元素\nfirstArray[0] = \"swift\"\n\n// 合并数组\nfirstArray+secondArray\n\n// 计算数组元素的个数\nfirstArray.count\n\n// 判断数组是否为空\nfirstArray.isEmpty\n\n// 删除数组元素\nfirstArray.remove(at: 0)\n```\n\n### Set\n\n> 集合是用来存储类型相同且没有确定顺序的唯一的值，不允许插入已存在的值\n\n```swift\n// 创建集合\nlet firstSet = Set([\"hello\",\"world\",\"manon\",\"icu\",\"swift\"])\nlet secondSet = Set([\"just\",\"do\",\"it\"])\n\n// 访问集合\nfor item in firstSet{\n\tprint(item) //\"hello\",\"world\",\"manon\",\"icu\",\"swift\"\n}\n\n// 判断是否为空\nfirstSet.isEmpty // false\n\n// 计算集合的长度\nfirstSet.count //5\n\n// 判断是否包含某个元素\nfirstSet.contains(\"manon\") //true\n\n// 向集合添加元素\nfirstSet.insert(\"funny\")\n\n// 删除集合的元素\nfirstSet.remove(\"manon\")\n\n// 合并集合\nfirstSet.union(secondSet)\n```\n\n### Tuple\n\n> Swift 中的 tuple 允许存储不同类型的固定数量的值。创建元组后，不能从该元组中添加或删除值。\n\n```swift\n// 创建tuple\nlet firstTuple = (name: \"manon\", level: 9000, Nationality: \"china\")\n\n// 访问tuple\nfirstTuple.name // manon\n```\n\n### Dictionary\n\n> Swift 字典用来存储无序的相同类型数据的集合，Swift 字典会强制检测元素的类型，如果类型不同则会报错。 Swift 字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。 Swift 字典的 key 没有类型限制可以是整型或字符串，但必须是唯一的。\n\n```swift\n// 创建字典\nlet firstDictionary = [\"Gintama\" : \"Sakata Gintoki\", \"Haikyuu\" : \"Shoyo Hinata\"]\n\n// 访问字典\nfirstDictionary[\"Gintama\"] // Sakata Gintoki\n\n// 修改字典\nfirstDictionary.updateValue(\"manon\",forKey:Gintama)\n// 或\nfirstDictionary[\"Gintama\"] = \"manon\"\n\n// 删除字典元素\nfirstDictionary.removeValue(\"Gintama\")\n\n// 遍历字典\nfor (key,value) in firstDictionary{\n\tprint(\"字典 key \\(key) -  字典 value \\(value)\")\n}\n\n// 计算字典长度\nfirstDictionary.count\n\n// 判断字典是否为空\nfirstDictionary.isEmpty\n```\n\n### Enums\n\n> 根据 Swift 文档枚举的定义，它是“一组相关值的公共类型，使您能够在代码中以类型安全的方式处理这些值”。可以把它看作是一种特别用于 switch/conditions 的变量类型。\n\n```swift\n// 创建Enums\nenum enumname {\n   // 枚举定义放在这里\n}\n\n// 实例\n\nimport Cocoa\n\nenum DaysofaWeek {\n    case Sunday\n    case Monday\n    case TUESDAY\n    case WEDNESDAY\n    case THURSDAY\n    case FRIDAY\n    case Saturday\n}\n\nvar weekDay = DaysofaWeek.THURSDAY\nweekDay = .THURSDAY\nswitch weekDay{\n\tcase .Sunday:\n\t\tprint(\"星期天\")\n\tcase .Monday:\n\t\tprint(\"星期一\")\n\tcase .TUESDAY:\n\t\tprint(\"星期二\")\n\tcase .WEDNESDAY:\n\t\tprint(\"星期三\")\n\tcase .THURSDAY:\n\t\tprint(\"星期四\")\n\tcase .FRIDAY:\n\t\tprint(\"星期五\")\n\tcase .Saturday:\n\t\tprint(\"星期六\")\n}\n```\n","slug":"swift/100days/day02"}]},"__N_SSG":true}