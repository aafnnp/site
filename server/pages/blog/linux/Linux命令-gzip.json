{"pageProps":{"data":{"date":"October 9, 2020","title":"Linux命令gzip","tags":["linux"],"description":"“gzip”命令的快速指南，用于压缩文件","fromNow":"a year ago"},"content":{"compiledSource":"var c=Object.defineProperty,t=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,g=Object.prototype.propertyIsEnumerable;var m=(e,p,a)=>p in e?c(e,p,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[p]=a,r=(e,p)=>{for(var a in p||(p={}))i.call(p,a)&&m(e,a,p[a]);if(l)for(var a of l(p))g.call(p,a)&&m(e,a,p[a]);return e},o=(e,p)=>t(e,d(p));var s=(e,p)=>{var a={};for(var n in e)i.call(e,n)&&p.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&l)for(var n of l(e))p.indexOf(n)<0&&g.call(e,n)&&(a[n]=e[n]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,p=s(n,[\"components\"]);return mdx(MDXLayout,o(r(r({},layoutProps),p),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"\\u201Cgzip\\u201D\\u547D\\u4EE4\\u7684\\u5FEB\\u901F\\u6307\\u5357\\uFF0C\\u7528\\u4E8E\\u538B\\u7F29\\u6587\\u4EF6\"),mdx(\"p\",null,\"gzip \\u547D\\u4EE4\\u53EF\\u4EE5\\u5728 Linux\\u3001macOS\\u3001WSL \\u548C\\u4EFB\\u4F55\\u6709 UNIX \\u73AF\\u5883\\u7684\\u5730\\u65B9\\u4F7F\\u7528\\u3002\"),mdx(\"p\",null,\"\\u60A8\\u53EF\\u4EE5\\u4F7F\\u7528 gzip \\u547D\\u4EE4\\u4F7F\\u7528\\u540D\\u4E3A\",mdx(\"a\",r({parentName:\"p\"},{href:\"https://en.wikipedia.org/wiki/LZ77_and_LZ78\"}),\"LZ77\"),\"\\u7684 gzip \\u538B\\u7F29\\u534F\\u8BAE\\u538B\\u7F29\\u6587\\u4EF6\\u3002\"),mdx(\"h2\",null,\"\\u4F7F\\u7528\\u65B9\\u6CD5\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip filename\n`)),mdx(\"p\",null,\"\\u8FD9\\u5C06\\u538B\\u7F29\\u6587\\u4EF6\\uFF0C\\u5E76\\u5411\\u5176\\u9644\\u52A0\\u4E00\\u4E2A.gz \\u6269\\u5C55\\u540D\\uFF0C\\u539F\\u59CB\\u6587\\u4EF6\\u5C06\\u88AB\\u5220\\u9664\\u3002\\u4E3A\\u4E86\\u9632\\u6B62\\u51FA\\u73B0\\u8FD9\\u79CD\\u60C5\\u51B5\\uFF0C\\u53EF\\u4EE5\\u4F7F\\u7528\",mdx(\"inlineCode\",{parentName:\"p\"},\"-C\"),\"\\u9009\\u9879\\u5E76\\u4F7F\\u7528\\u8F93\\u51FA\\u91CD\\u5B9A\\u5411\\u5C06\\u8F93\\u51FA\\u5199\\u5165\\u6587\\u4EF6\\u540D.gz \\u6587\\u4EF6\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip -c filename > filename.gz\n`)),mdx(\"p\",null,\"-C \\u9009\\u9879\\u6307\\u5B9A\\u8F93\\u51FA\\u5C06\\u8F6C\\u5230\\u6807\\u51C6\\u8F93\\u51FA\\u6D41\\uFF0C\\u4FDD\\u7559\\u539F\\u59CB\\u6587\\u4EF6\\u4E0D\\u53D8\"),mdx(\"p\",null,\"\\u540C\\u65F6\\u4E5F\\u53EF\\u4EE5\\u4F7F\\u7528-K \\u9009\\u9879\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip -k filename\n`)),mdx(\"p\",null,\"\\u538B\\u7F29\\u8D8A\\u591A\\uFF0C\\u538B\\u7F29\\uFF08\\u548C\\u89E3\\u538B\\u7F29\\uFF09\\u6240\\u9700\\u7684\\u65F6\\u95F4\\u5C31\\u8D8A\\u957F\\u3002\\u7EA7\\u522B\\u8303\\u56F4\\u4ECE 1\\uFF08\\u6700\\u5FEB\\u3001\\u6700\\u5DEE\\u7684\\u538B\\u7F29\\uFF09\\u5230 9\\uFF08\\u6700\\u6162\\u3001\\u66F4\\u597D\\u7684\\u538B\\u7F29\\uFF09\\uFF0C\\u9ED8\\u8BA4\\u503C\\u4E3A 6\\u3002\\u60A8\\u53EF\\u4EE5\\u4F7F\\u7528-\",mdx(\"inlineCode\",{parentName:\"p\"},\"<NUMBER>\"),\"\\u9009\\u9879\\u9009\\u62E9\\u7279\\u5B9A\\u7EA7\\u522B\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip -1 filename\n`)),mdx(\"p\",null,\"\\u538B\\u7F29\\u591A\\u6587\\u4EF6\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip filename1 filename2\n`)),mdx(\"p\",null,\"\\u4F7F\\u7528-r \\u9009\\u9879\\u9012\\u5F52\\u5730\\u538B\\u7F29\\u76EE\\u5F55\\u4E2D\\u7684\\u6240\\u6709\\u6587\\u4EF6\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip -r a_folder\n`)),mdx(\"p\",null,\"-v \\u9009\\u9879\\u6253\\u5370\\u538B\\u7F29\\u767E\\u5206\\u6BD4\\u4FE1\\u606F\\u3002\\u4E0B\\u9762\\u662F\\u4E00\\u4E2A\\u4E0E-k\\uFF08keep\\uFF09\\u9009\\u9879\\u4E00\\u8D77\\u4F7F\\u7528\\u7684\\u793A\\u4F8B\\uFF1A\"),mdx(\"p\",null,mdx(\"img\",r({parentName:\"p\"},{src:\"https://cdn.jsdelivr.net/gh/funnyPan/pics@master/uPic/fvzBBf.png\",alt:\"fvzBBf\"}))),mdx(\"p\",null,\"gzip \\u8FD8\\u53EF\\u4EE5\\u7528\\u4E8E\\u89E3\\u538B\\u7F29\\u6587\\u4EF6\\uFF0C\\u4F7F\\u7528-d \\u9009\\u9879\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`gzip -d filename.gz\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"October 9, 2020","title":"Linux命令gzip","tags":["linux"],"description":"“gzip”命令的快速指南，用于压缩文件","fromNow":"a year ago"}},"randomPost":[{"data":{"date":"April 2, 2021","title":"变量、基本数据类型、字符串插值","tags":["swift"],"description":"swift 提供的数据类型包括：整形 Int、浮点数 Double 和 Float、布尔类型 Bool 以及字符串类型 String、Optional、Array、Dictionary、Struct、Class 等。","fromNow":"8 months ago"},"content":"\n## 变量\n\n变量是一种使用方便的占位符，用于引用计算机内存地址。\n\nswift 每个变量指定了特定的类型，类型决定变量占用内存的大小，也决定可存储值的范围。\n\n变量名可以由字母、数字和下划线组成，以字母或下划线开始，且区分大小写。\n\n变量名也可以使用简单的 Unicode 字符\n\n变量和常量可以使用 print 函数输出，在字符串中可以使用括号与反斜线插入变量\n\n```swift\n// 变量声明\nvar variableName = <initial value>\n\n//实例\nimport Cocoa\n\nvar a = 42\nprint(a) //输出42\n\nvar b:float\nb = 3.1415926\nprint(b) //输出3.1415926\n\nvar _var = \"hello swift\"\nvar 你好 = \"世界\"\nprint(_var) // hello swift\nprint(你好) //世界\n\nvar name = \"manon\"\n\nprint(\"\\(name)\") //manon\n```\n\n标准 Swift 字符串使用双引号，但不能包含换行符，如果您想要多行字符串，使用三个双引号开始和结束，如下所示：\n\n```swift\nvar str1 = \"\"\"\nThis goes\nover multiple\nlines\n\"\"\"\nprint(str1) // \"This goes\\nover multiple\\nlines\"\n```\n\n如果不希望显示`\\`，应该如下写：\n\n```swift\nvar str2 = \"\"\"\nThis goes \\\nover multiple \\\nlines\n\"\"\"\nprint(str2) //\"This goes nover multiple nlines\"\n```\n\n## 浮点和布尔值\n\nSwift 中的另外两种基本数据类型是双精度和布尔值。\n\n```swift\nvar pi = 3.141\nvar awesome = true\n```\n\n## 字符串插值\n\n> 将变量放置在字符串中\n\n```swift\nvar score = 85\nvar str = \"Your score was \\(score)\"\n\nvar results = \"The test results are here: \\(str)\"\n```\n\n## 常量\n\n> 常量一旦赋值，不能再次赋值，否则会报错。\n\n```swift\n//声明\nlet _const = <initial value>\nlet _const:Float = 3.1415926\n\n// 命名\n和变量命名相同\n// 输出\n和变量命名相同\n```\n\n## 类型声明\n\n在创建变量或常量的时候可以声明数据类型，如果没有，swift 将推导其数据类型，如下：\n\n```swift\nlet str = \"Hello, playground\" //swift推导str为String\n\n// 主动声明类型\nlet album: String = \"Reputation\"\nlet year: Int = 1989\nlet height: Double = 1.78\nlet taylorRocks: Bool = true\n```\n\n## 扩展\n\n字符串是一系列字符的集合，比如`hello world`，它的数据类型为 String\n\n```swift\nimport Cocoa\n//创建字符串\nvar str1 = \"hello world\"\nprint(str1)\n\n//空字符串\nvar str2 = \"\"\nvar str3 = \" manon\"\nif str2.isEmpty() {\n\tprint(\"str2 是空字符串\")\n}else{\n\tprint(\"str2 不是空字符串\")\n}\n\n// 连接字符串\n\nvar str4 = str1 + str3\nprint(str4) //\"hello world manon\"\nprint('str1和str3连接：\\(str4)')\n\n// 字符串长度\nprint(str4.count)\n\n// 字符串比较\nif str1==str2{\n\tprint(\"\\(str1) 与 \\(str2)是相等的\")\n}else{\n\tprint(\"\\(str1) 与 \\(str2)是不相等的\")\n}\n```\n\n字符串函数及运算符\n\n- isEmpty `判断字符串是否为空，返回布尔值`\n- hasPrefix `检查字符串是否有特定的前缀`\n- hasSuffix `检查字符串是否有特定的后缀`\n- Int `转换字符串数字为整型`\n- count `计算字符串的长度`\n- utf8、utf16 `遍历String的utf8属性访问utf8、utf16编码`\n- unicodeScalars `遍历String的unicodeScalars属性访问Unicode标量编码`\n- +、+=、==、<、！= `字符串操作符`\n","slug":"swift/100days/day01"},{"data":{"date":"May 9, 2018","title":"String","tags":["javascript"],"fromNow":"4 years ago"},"content":"\n## String\n\n### 方法\n\n- String.fromCharCode() //通过一串 Unicode 创建字符串。\n- String.fromCodePoint() //通过一串 码点 创建字符串。\n- String.raw() //通过模板字符串创建字符串。\n\n### 实例方法\n\n- charAt(i)\n- charCodeAt(i)\n- codePointAt(i)\n- concat(str)\n- endsWith(str)\n- includes(str)\n- indexOf(str)\n- lastIndexOf(str)\n- localeCompare()\n- match(regex)\n- normalize()\n- padEnd()\n- padStart()\n- repeat()\n- replace(str1, str2)\n- search(str)\n- slice(begin, end)\n- split(separator)\n- startsWith(str)\n- substring()\n- toLocaleLowerCase()\n- toLocaleUpperCase()\n- toLowerCase()\n- toString()\n- toUpperCase()\n- trim()\n- trimEnd()\n- trimStart()\n- valueOf()\n\n### charAt\n\n> 返回指定位置的字符,且返回的字符长度为 1，**_js 没有一种有别于字符串类型的字符数据类型_**\n\n```javascript\nstring.charAt(index);\n\n'porhub'.charAt(0); //'p'\n'porhub'.charAt(1); //'o'\n'porhub'.charAt(2); //'r'\n```\n\n### charCodeAt\n\n> 返回在指定的位置的字符的 Unicode 编码\n\n**字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN。**\n\n```javascript\nstring.charCodeAt(index);\n\n'porhub'.charCodeAt(0); //112\n'porhub'.charCodeAt(1); //111\n'porhub'.charCodeAt(2); //114\n```\n\n### codePointAt\n\n> ES2015 引入的，用于处理 2 UTF-16 字符的，比如中文，在 ES2015 之前 charCodeAt 只能处理单个字符，处理双字符必须一个个处理然后拼接。\n\n```javascript\nstring.codePointAt(index);\n\n//ES2015之前\n'𠮷'.charCodeAt(0).toString(16); //d842\n'𠮷'.charCodeAt(1).toString(16); //dfb7\n('\\ud842\\udfb7'); //𠮷\n\n//ES2015\n'𠮷'.codePointAt(0); //20bb7\n('\\u{20bb7}'); //𠮷\n```\n\n### concat\n\n> 类似 Array 的 concat\n\n```javascript\nstringObject.concat(stringX,stringX,...,stringX)\n\n\"browser\".concat(\"porhub\");\n```\n\n通常使用 + 拼接来得更方便，或者使用 ES2015 的``字符扩展。\n\n### endWith\n\n> 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。\n\n```javascript\nstr.endsWith(searchString, position);\n\n'JavaScript'.endsWith('Script'); //true\n'JavaScript'.endsWith('script'); //false\n'JavaScript'.endsWith('Script', 5); //false\n'JavaScript'.endsWith('as', 5); //true\n```\n\n### includes\n\n> 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false\n\n```javascript\nstr.includes(searchString, position);\n\n'JavaScript'.includes('Script'); //true\n'JavaScript'.includes('script'); //false\n'JavaScript'.includes('nice'); //true\n'JavaScript'.includes('nice', 3); //false\n```\n\n### indexOf\n\n> 用于返回字符串中出现某个字符的初始位置，如果没有找到，返回-1.\n\n```javascript\nstr.indexOf(searchString, startPosition);\n\n'JavaScript'.indexOf('a'); //1\n'JavaScript'.indexOf('a', 2); //3\n```\n\n### lastIndexOf\n\n> 用于返回某个字符最后出现的位置，如果没有，返回-1\n\n```javascript\nstr.lastIndexOf(searchString, startPosition);\n\n'JavaScript'.lastIndexOf('a'); //3\n'JavaScript'.lastIndexOf('a', 1); //1\n```\n\n### padEnd\n\n> 用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n\n```javascript\nstr.padEnd(targetLength, string);\n\n'abc'.padEnd(10); // \"abc       \"\n'abc'.padEnd(10, 'foo'); // \"abcfoofoof\"\n'abc'.padEnd(6, '123456'); // \"abc123\"\n'abc'.padEnd(1); // \"abc\"\n```\n\n### padStart\n\n> 用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的\n\n```javascript\nstr.padStart(targetLength, string);\n\n'abc'.padStart(10); // \"       abc\"\n'abc'.padStart(10, 'foo'); // \"foofoofabc\"\n'abc'.padStart(6, '123465'); // \"123abc\"\n'abc'.padStart(8, '0'); // \"00000abc\"\n'abc'.padStart(1); // \"abc\"\n```\n\n### repeat\n\n> 构造并返回一个包含被连接在一起的指定数量的新字符串。\n\n```javascript\nstr.repeat(count);\n\n'abc'.repeat(-1); // RangeError: repeat count must be positive and less than inifinity\n'abc'.repeat(0); // \"\"\n'abc'.repeat(1); // \"abc\"\n'abc'.repeat(2); // \"abcabc\"\n'abc'.repeat(3.5); // \"abcabcabc\" 参数count将会被自动转换成整数.\n'abc'.repeat(1 / 0); // RangeError: repeat count must be positive and less than inifinity\n```\n\n### slice\n\n> 截取字符串的一部分，并返回一个新的字符串\n\n```javascript\nstr.slice(startPosition, endPosition);\n\n'abc'.slice(0, 1); //a\n'abc'.slice(0, -1); //ab\n```\n\n### split\n\n> 将字符串切割成数组\n\n```javascript\nstr.split(separator, limit);\n\n'abc'.split(); //\"[a,b,c]\";\n'a,b,c'.split(',', 1); //[a]\n```\n\n### startWith\n\n> 判断字符串是否以给定的字符串开始，返回 true/false\n\n```javascript\nstr.startsWith(searchString, poistion);\n\n'abc'.startsWith('a'); //true\n'abc'.startsWith('a', 1); //false\n```\n\n### substring\n\n> 根据开始索引到结束索引截取字符串\n\n```javascript\nstr.substring(startPosition, endPosition);\n\n'abc'.substring(0, 1); //a\n'abc'.substring(-1); //abc\n```\n\n1. 如果 startPosition 等于 indexEnd，substring 返回一个空字符串。\n2. 如果省略 indexEnd，substring 提取字符一直到字符串末尾。\n3. 如果任一参数小于 0 或为 NaN，则被当作 0。\n4. 如果任一参数大于 stringName.length，则被当作 stringName.length。\n5. 如果 startPosition 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。见下面的例子。\n\n### toLocaleLowerCase/toLocaleUpperCase/toUpperCase/toLowerCase\n\n> 将字符串转换成小写/大写\n\n```javascript\nstr.toLocaleLowerCase() /\n  str.toLocaleUpperCase() /\n  str.toUpperCase() /\n  str.toLowerCase();\n\n'ABC'.toLocaleLowerCase(); //abc\n'abc'.toLocaleUpperCase(); //ABC\n```\n\n### toString\n\n> 将\\*转换成字符串\n\n```javascript\nvar x = new String('Hello world');\n\nalert(x.toString()); // 输出 \"Hello world\"\n```\n\n### trim/trimStart/trimEnd\n\n> 移除空白字符/起始位置空白字符/结尾位置空白字符\n\n```javascript\nstr.trim() / str.trimStart() / str.trimEnd();\n\n'Testing'.trim(); //'Testing'\n' Testing'.trim(); //'Testing'\n' Testing '.trim(); //'Testing'\n'Testing '.trim(); //'Testing'\n```\n\n### valueOf\n\n> 返回 str 的原始值，等同于 String.prototype.toString\n\n```javascript\nstr.valueOf();\n\nx = new String('Hello world');\nalert(x.valueOf()); // Displays \"Hello world\"\n```\n\n### 扩展学习\n\n```javascript\n1 +\n  '5'[(1, 3, 5)] + //\"15\"\n  1; //\"1,3,51\"\n10 + true; // 11\n15 + {}; // \"15[object Object]\"\n8 + null; // 8\n'queen' + null; // \"queennull\"\n12 + undefined; // NaN\n```\n\n[See examples in jsbin](http://jsbin.com/fiwemir/2/edit?js,console)\n","slug":"javascript/base/String"},{"data":{"date":"May 21, 2020","title":"Go-HelloWorld","tags":["go"],"fromNow":"2 years ago"},"content":"\n## 搭建开发环境\n\n让我们创建一个目录，在该目录中编写我们的 hello world 程序。打开终端并运行以下命令。\n\n```shell\nmkdir ~/Documents/learngo/\n```\n\n上面的命令将 learngo 在当前用户的 Documents 目录中创建一个名为目录。\n\n### 你好，世界\n\n使用您喜欢的文本编辑器 main.go 在 learngo 目录中创建一个名为以下内容的文件。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello World\")\n}\n```\n\n按照 Go 中的约定，将包含 main 函数的文件命名为 main.go。\n\n### 运行程序\n\n1. go install\n\n```shell\ncd ~/Documents/learngo/\ngo install\n#此命令将编译程序并将编译好的二进制文件复制到~/go/bin内\nls -al ~/go/bin/\n\n~/go/bin/learngo\n#输出hello world\n```\n\n2. go build\n\n```shell\ncd ~/Documents/learngo/\ngo build\n#上面的命令将learngo在当前目录中创建一个二进制文件。ls -al将显示learngo已创建一个名为的文件。\n./learngo\n#输出Hello World\n```\n\n3. go run\n\ncd ~/Documents/learngo/在终端中键入命令以将当前目录更改为 learngo。\n\n```shell\ngo run main.go\nHello World\n#go run和go build/go install命令之间的细微差别是，go run需要.go文件名作为参数。\n```\n\ngo run 工作原理非常相似 go build。无需将程序编译并安装到当前目录，而是将文件编译到一个临时位置并从该位置运行文件。如果您想知道 go run 将文件编译到的位置，请 go run 使用--work 参数运行。\n\n```shell\ngo run --work main.go\n```\n\n4. go playground\n\n<Gist gistLink=\"Manonicu/ef552d29300ffb0cd311d9cc8828bc6e\" />\n\n我们将简要讨论该程序的每一行的作用。\n\n- package main - 每个 go 文件必须以 package name 开始。\n- import \"fmt\" - import 语句用于导入其他软件\n\n  包\n\n- func main（）- func 关键字标记函数的开始。\n- fmt.Println（\"H​​ello World\"）\n","slug":"go/第一个Go程序"},{"data":{"date":"May 19, 2020","title":"执行上下文","tags":["javascript"],"fromNow":"2 years ago"},"content":"","slug":"javascript/advance/执行上下文"},{"data":{"date":"July 30, 2017","title":"css的小技巧","tags":["css"],"fromNow":"4 years ago"},"content":"\n1. 使用 CSS 复位\n\n不同浏览器有不同的自带初始样式，通常可以使用 normalize.css、tinyreset.css 进行通配初始化。\n\n```css\n*,\n*:after,\n*:before {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n```\n\n2. 继承 box-sizing\n\n```css\nhtml {\n  box-sizing: border-box;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: inherit;\n}\n```\n\n3. 使用 unset 而不是重置所有属性\n4. 使用 :not() 选择器来决定表单是否显示边框\n5. 为 body 元素添加行高\n6. 為表單元素設置:focus\n7. 垂直居中任何元素\n8. 逗号分隔的列表\n9. 使用负的 nth-child 来选择元素\n10. 使用 SVG 图标\n11. 使用 “形似猫头鹰” 的选择器\n12. 使用 max-height 来建立纯 CSS 的滑块\n13. 创造格子等宽的表格\n14. 利用 Flexbox 去除多余的外边距\n15. 利用属性选择器来选择空链接\n16. 给 “默认” 链接定义样式\n17. 一致的垂直节奏\n18. 内在比例盒\n19. 为破碎图象定义样式\n20. 用 rem 来调整全局大小；用 em 来调整局部大小\n21. 隐藏没有静音、自动播放的影片\n22. 使用选择器 :root 来控制字体弹性\n23. 为更好的移动体验，为表单元素设置字体大小\n24. 使用指针事件來控制鼠标事件\n","slug":"css/小技巧-ChicksTricks"},{"data":{"date":"October 28, 2020","title":"Linux命令traceroute","tags":["linux"],"description":"traceroute命令用于显示数据包到主机之间的路径","fromNow":"a year ago"},"content":"\n**traceroute**命令用于显示数据包到主机之间的路径。\n\n> raceroute 命令 用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。\n>\n> 通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。\n>\n> traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其 ip 地址。\n\n## 使用方法\n\n```shell\ntraceroute <host>\n```\n\n## 案例\n\n![1EOlsJ](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/1EOlsJ.png)\n\n## 参数\n\n- -d 使用 Socket 层级的排错功能。\n- -f<存活数值> 设置第一个检测数据包的存活数值 TTL 的大小。\n- -F 设置勿离断位。\n- -g<网关> 设置来源路由网关，最多可设置 8 个。\n- -i<网络界面> 使用指定的网络界面送出数据包。\n- -I 使用 ICMP 回应取代 UDP 资料信息。\n- -m<存活数值> 设置检测数据包的最大存活数值 TTL 的大小。\n- -n 直接使用 IP 地址而非主机名称。\n- -p<通信端口> 设置 UDP 传输协议的通信端口。\n- -r 忽略普通的 Routing Table，直接将数据包送到远端主机上。\n- -s<来源地址> 设置本地主机送出数据包的 IP 地址。\n- -t<服务类型> 设置检测数据包的 TOS 数值。\n- -v 详细显示指令的执行过程。\n- -w<超时秒数> 设置等待远端主机回报的时间。\n- -x 开启或关闭数据包的正确性检验。\n\n**traceroute**命令可在 Linux、macOS、WSL 和任何 UNIX 环境下运行\n","slug":"linux/Linux命令-traceroute"}]},"__N_SSG":true}