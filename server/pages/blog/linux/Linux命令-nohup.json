{"pageProps":{"data":{"date":"October 11, 2020","title":"Linux命令nohup","tags":["linux"],"description":"用于忽略 SIGHUP (挂断信号) 在系统后台不挂断地运行命令，退出终端不会影响程序的运行","fromNow":"a year ago"},"content":{"compiledSource":"var h=Object.defineProperty,c=Object.defineProperties;var i=Object.getOwnPropertyDescriptors;var u=Object.getOwnPropertySymbols;var t=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable;var r=(p,e,n)=>e in p?h(p,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):p[e]=n,o=(p,e)=>{for(var n in e||(e={}))t.call(e,n)&&r(p,n,e[n]);if(u)for(var n of u(e))l.call(e,n)&&r(p,n,e[n]);return p},m=(p,e)=>c(p,i(e));var s=(p,e)=>{var n={};for(var a in p)t.call(p,a)&&e.indexOf(a)<0&&(n[a]=p[a]);if(p!=null&&u)for(var a of u(p))e.indexOf(a)<0&&l.call(p,a)&&(n[a]=p[a]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var a=n,{components:p}=a,e=s(a,[\"components\"]);return mdx(MDXLayout,m(o(o({},layoutProps),e),{components:p,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"nohup\"),'\\u7528\\u4E8E\\u5FFD\\u7565 SIGHUP (\"signal hang up\" \\u8BD1\\uFF1A\\u6302\\u65AD\\u4FE1\\u53F7) \\u5728\\u7CFB\\u7EDF\\u540E\\u53F0\\u4E0D\\u6302\\u65AD\\u5730\\u8FD0\\u884C\\u547D\\u4EE4\\uFF0C\\u9000\\u51FA\\u7EC8\\u7AEF\\u4E0D\\u4F1A\\u5F71\\u54CD\\u7A0B\\u5E8F\\u7684\\u8FD0\\u884C\\u3002'),mdx(\"p\",null,\"nohup \\u547D\\u4EE4\\u5728\\u9ED8\\u8BA4\\u60C5\\u51B5\\u4E0B\\uFF08\\u975E\\u91CD\\u5B9A\\u5411\\u65F6\\uFF09\\uFF0C\\u4F1A\\u8F93\\u51FA\\u4E00\\u4E2A\\u540D\\u53EB nohup.out \\u7684\\u6587\\u4EF6\\u5230\\u5F53\\u524D\\u76EE\\u5F55\\u4E0B\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u76EE\\u5F55\\u7684 nohup.out \\u6587\\u4EF6\\u4E0D\\u53EF\\u5199\\uFF0C\\u8F93\\u51FA\\u91CD\\u5B9A\\u5411\\u5230 $HOME/nohup.out \\u6587\\u4EF6\\u4E2D\\u3002\"),mdx(\"h2\",null,\"\\u4F7F\\u7528\\u65B9\\u6CD5\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-shell\"}),`nohup <command>\n`)),mdx(\"p\",null,\"\\u505C\\u6B62\\u8FD0\\u884C\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-shell\"}),`#\\u4F7F\\u7528\\u5982\\u4E0B\\u547D\\u4EE4\\u627E\\u5230\\u8FDB\\u7A0Bpid\\uFF0C\\u7136\\u540E\\u4F7F\\u7528kill\\u6740\\u6389\\u8FDB\\u7A0B\nps -aux | grep <command>\n`)),mdx(\"h2\",null,\"\\u53C2\\u6570\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Command\\uFF1A\\u8981\\u6267\\u884C\\u7684\\u547D\\u4EE4\\u3002\"),mdx(\"li\",{parentName:\"ul\"},\"Arg\\uFF1A\\u4E00\\u4E9B\\u53C2\\u6570\\uFF0C\\u53EF\\u4EE5\\u6307\\u5B9A\\u8F93\\u51FA\\u6587\\u4EF6\\u3002\"),mdx(\"li\",{parentName:\"ul\"},\"&\\uFF1A\\u8BA9\\u547D\\u4EE4\\u5728\\u540E\\u53F0\\u6267\\u884C\\uFF0C\\u7EC8\\u7AEF\\u9000\\u51FA\\u540E\\u547D\\u4EE4\\u4ECD\\u65E7\\u6267\\u884C\\u3002\")),mdx(\"p\",null,\"nohup \\u547D\\u4EE4\\u53EF\\u4EE5\\u5728 Linux\\u3001macOS\\u3001WSL \\u548C\\u4EFB\\u4F55\\u6709 UNIX \\u73AF\\u5883\\u7684\\u5730\\u65B9\\u4F7F\\u7528\"))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"October 11, 2020","title":"Linux命令nohup","tags":["linux"],"description":"用于忽略 SIGHUP (挂断信号) 在系统后台不挂断地运行命令，退出终端不会影响程序的运行","fromNow":"a year ago"}},"randomPost":[{"data":{"date":"February 10, 2019","title":"online&offline","tags":["javascript"],"description":"当浏览器从在线与离线状态中切换时，这两个事件会在页面的 body 上触发","fromNow":"3 years ago"},"content":"\n> 当浏览器从在线与离线状态中切换时，这两个事件会在页面的 body 上触发，并冒泡到 document 和 window。可使用 window、document、document.body、添加监听事件`addEventListener`。\n\n## 使用方法\n\n```javascript\n//网络状态\nwindow.addEventListener('load', () => {\n  const updateOnlineStatus = () => {\n    this.online = navigator.onLine;\n  };\n\n  window.addEventListener('online', updateOnlineStatus);\n  window.addEventListener('offline', updateOnlineStatus);\n});\n```\n","slug":"apis/online-offline"},{"data":{"date":"May 19, 2020","title":"继承","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 构造继承\n\n## 原型继承\n\n## 实例继承\n\n## 拷⻉继承\n\n## 原型 prototype 机制或 apply 和 call ⽅法去实现较简单，建议使⽤构造函数与原型混合⽅式\n\n```javascript\nfunction Parent() {\n  this.name = 'wang';\n}\nfunction Child() {\n  this.age = 28;\n}\nChild.prototype = new Parent(); //继承了Parent，通过原型\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name); //得到被继承的属性\n```\n","slug":"javascript/advance/js的继承"},{"data":{"date":"May 15, 2018","title":"Array","tags":["javascript"],"fromNow":"4 years ago"},"content":"\n## 属性\n\n1. Array.length - 静态属性，值为 1\n2. Array.prototype - 数组的原型对象\n\n## 方法\n\n1. Array.from - 从类数组对象或者可迭代对象中创建一个新的数组实例\n2. Array.of - 根据一组参数来创建新的数组实例，支持任意的参数数量和类型\n3. Array.isArray - 判断是否为数组\n\n### 实例\n\n#### 属性\n\n1. Array.prototype.length - 空数组，值为 0\n2. Array.prototype.constructor - 所有的数组实例都继承了这个属性，值为 Array\n\n#### 实例方法\n\n##### 修改器方法 - 改变调用它们的对象自身的值\n\n- Array.prototype.copyWithin //将数组 copy 到另一个数组，并覆盖原值\n- Array.prototype.fill //填充数组\n- Array.prototype.pop //删除数组最后一个值，并返回该值\n- Array.prototype.push //向数组最后添加一个新的元素或多个元素，并返回数组的长度\n- Array.prototype.reverse //颠倒数组\n- Array.prototype.shift //删除数组第一个元素并返回该元素\n- Array.prototype.sort //排序\n- Array.prototype.splice //在数组任意位置添加或删除元素\n- Array.prototype.unshift //在数组开头添加一个或多个元素并返回数组长度\n\n##### 访问方法 - 不会改变调用它们的对象自身的值，只会返回新数组或期望值\n\n- Array.prototype.concat //返回当前数组和其他数组的组合\n- Array.prototype.includes //数组是否包含某个值，返回 true/false\n- Array.prototype.join //返回数组所有元素组成的字符串\n- Array.prototype.slice //截取数组的某一段\n- Array.prototype.toString //转换成字符串\n- Array.prototype.toLocalString //转换成本地字符串\n- Array.prototype.indexOf //返回数组中第一个与指定值相等的索引\n- Array.prototype.lastIndexOf //返回数组中最后一个与指定值相等的索引\n\n##### 迭代方法\n\n- Array.prototype.forEach //为数组中每个元素执行一次回调函数\n- Array.prototype.entries //返回数组元素的键值对\n- Array.prototype.every //如果每个元素都满足回调函数就返回 true，否则返回 false\n- Array.prototype.some //如果数组中元素至少有一个满足回调函数就返回 true，否则返回 false\n- Array.prototype.filter //过滤数组中满足回调函数的元素\n- Array.prototype.find //查找数组中满足回调函数的元素，如果没有则返回 undefined\n- Array.prototype.findIndex //返回数组中满足回调函数的索引，没有则返回-1\n- Array.prototype.keys //返回数组中的键\n- Array.prototype.map //返回一个由回调函数组成的新数组\n- Array.prototype.reduce //从右向左为每个元素执行一次回调函数，并将上次回调函数的返回值暂存，然后传递给下一个回调函数\n- Array.prototype.reduceRight //与 reduce 相反方向\n- Array.prototype.values //返回数组中的值\n\n## 扩展学习\n\n### 四种合并数组的方法\n\n1. 循环\n\n```javascript\nfunction push(fromArray, toArray) {\n  for (let i = 0, len = fromArray.length; i < len; i++) {\n    toArray.push(fromArray[i]);\n  }\n  return toArray;\n}\n\nvar array1 = [1, 2, 3, 4, 5];\nvar array2 = [6, 7, 8, 9, 10];\nvar array3 = [];\npush(array1, array3);\npush(array2, array3);\n```\n\n2. 解构\n\n```javascript\nvar array1 = [1, 2, 3, 4, 5];\nvar array2 = [6, 7, 8, 9, 10];\nvar array3 = [...array1, ...array2];\nvar array3 = Array.of(...array2, ...array1);\narray3; // [1,2,3,4,5,6,7,8,9,10];\n```\n\n3. concat\n\n```javascript\nvar array1 = [1, 2, 3, 4, 5];\nvar array2 = [6, 7, 8, 9, 10];\n\nvar array3 = array1.concat(array2);\n// or\nvar array3 = [].concat(array1, array2);\n```\n\n4. reduce\n\n```javascript\nvar array1 = [1,2,3,4,5];\nvar array2 = [6,7,8,9,10];\nvar array3 = array2.reduce((newArray, item) => {\n          newArray.push(item);\n          return newArray;\n ), array1);\n```\n","slug":"javascript/base/Array"},{"data":{"date":"April 2, 2021","title":"变量、基本数据类型、字符串插值","tags":["swift"],"description":"swift 提供的数据类型包括：整形 Int、浮点数 Double 和 Float、布尔类型 Bool 以及字符串类型 String、Optional、Array、Dictionary、Struct、Class 等。","fromNow":"8 months ago"},"content":"\n## 变量\n\n变量是一种使用方便的占位符，用于引用计算机内存地址。\n\nswift 每个变量指定了特定的类型，类型决定变量占用内存的大小，也决定可存储值的范围。\n\n变量名可以由字母、数字和下划线组成，以字母或下划线开始，且区分大小写。\n\n变量名也可以使用简单的 Unicode 字符\n\n变量和常量可以使用 print 函数输出，在字符串中可以使用括号与反斜线插入变量\n\n```swift\n// 变量声明\nvar variableName = <initial value>\n\n//实例\nimport Cocoa\n\nvar a = 42\nprint(a) //输出42\n\nvar b:float\nb = 3.1415926\nprint(b) //输出3.1415926\n\nvar _var = \"hello swift\"\nvar 你好 = \"世界\"\nprint(_var) // hello swift\nprint(你好) //世界\n\nvar name = \"manon\"\n\nprint(\"\\(name)\") //manon\n```\n\n标准 Swift 字符串使用双引号，但不能包含换行符，如果您想要多行字符串，使用三个双引号开始和结束，如下所示：\n\n```swift\nvar str1 = \"\"\"\nThis goes\nover multiple\nlines\n\"\"\"\nprint(str1) // \"This goes\\nover multiple\\nlines\"\n```\n\n如果不希望显示`\\`，应该如下写：\n\n```swift\nvar str2 = \"\"\"\nThis goes \\\nover multiple \\\nlines\n\"\"\"\nprint(str2) //\"This goes nover multiple nlines\"\n```\n\n## 浮点和布尔值\n\nSwift 中的另外两种基本数据类型是双精度和布尔值。\n\n```swift\nvar pi = 3.141\nvar awesome = true\n```\n\n## 字符串插值\n\n> 将变量放置在字符串中\n\n```swift\nvar score = 85\nvar str = \"Your score was \\(score)\"\n\nvar results = \"The test results are here: \\(str)\"\n```\n\n## 常量\n\n> 常量一旦赋值，不能再次赋值，否则会报错。\n\n```swift\n//声明\nlet _const = <initial value>\nlet _const:Float = 3.1415926\n\n// 命名\n和变量命名相同\n// 输出\n和变量命名相同\n```\n\n## 类型声明\n\n在创建变量或常量的时候可以声明数据类型，如果没有，swift 将推导其数据类型，如下：\n\n```swift\nlet str = \"Hello, playground\" //swift推导str为String\n\n// 主动声明类型\nlet album: String = \"Reputation\"\nlet year: Int = 1989\nlet height: Double = 1.78\nlet taylorRocks: Bool = true\n```\n\n## 扩展\n\n字符串是一系列字符的集合，比如`hello world`，它的数据类型为 String\n\n```swift\nimport Cocoa\n//创建字符串\nvar str1 = \"hello world\"\nprint(str1)\n\n//空字符串\nvar str2 = \"\"\nvar str3 = \" manon\"\nif str2.isEmpty() {\n\tprint(\"str2 是空字符串\")\n}else{\n\tprint(\"str2 不是空字符串\")\n}\n\n// 连接字符串\n\nvar str4 = str1 + str3\nprint(str4) //\"hello world manon\"\nprint('str1和str3连接：\\(str4)')\n\n// 字符串长度\nprint(str4.count)\n\n// 字符串比较\nif str1==str2{\n\tprint(\"\\(str1) 与 \\(str2)是相等的\")\n}else{\n\tprint(\"\\(str1) 与 \\(str2)是不相等的\")\n}\n```\n\n字符串函数及运算符\n\n- isEmpty `判断字符串是否为空，返回布尔值`\n- hasPrefix `检查字符串是否有特定的前缀`\n- hasSuffix `检查字符串是否有特定的后缀`\n- Int `转换字符串数字为整型`\n- count `计算字符串的长度`\n- utf8、utf16 `遍历String的utf8属性访问utf8、utf16编码`\n- unicodeScalars `遍历String的unicodeScalars属性访问Unicode标量编码`\n- +、+=、==、<、！= `字符串操作符`\n","slug":"swift/100days/day01"},{"data":{"date":"October 12, 2020","title":"Linux命令gunzip","tags":["linux"],"description":"“gunzip”命令的快速指南，用于解压缩gzip文件。","fromNow":"a year ago"},"content":"\n“gunzip”命令的快速指南，用于解压缩 gzip 文件。\n\n**gunzip**命令基本上等同于**gzip**命令，但默认情况-d 选项始终处于启用状态。\n\n## 使用方法\n\n```shell\ngunzip filename.gz\n```\n\n这将**gunzip**并删除**.gz**扩展名，将结果放入文件名文件中。如果该文件存在，它将覆盖该文件。\n\n可以使用-c 选项使用输出重定向将其提取到其他文件名：\n\n```shell\ngunzip -c filename.gz > anotherfilename\n```\n\ngunzip 命令可以在 Linux、macOS、WSL 和任何有 UNIX 环境的地方使用\n\n## 参数\n\n- -a 或--ascii 　使用 ASCII 文字模式。\n- -c 或--stdout 或--to-stdout 　把解压后的文件输出到标准输出设备。\n- -f 或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。\n- -h 或--help 　在线帮助。\n- -l 或--list 　列出压缩文件的相关信息。\n- -L 或--license 　显示版本与版权信息。\n- -n 或--no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。\n- -N 或--name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。\n- -q 或--quiet 　不显示警告信息。\n- -r 或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。\n- -S<压缩字尾字符串>或--suffix<压缩字尾字符串> 　更改压缩字尾字符串。\n- -t 或--test 　测试压缩文件是否正确无误。\n- -v 或--verbose 　显示指令执行过程。\n- -V 或--version 显示版本信息。\n","slug":"linux/Linux命令-gunzip"},{"data":{"date":"December 21, 2020","title":"Docker images","description":"Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器","tags":["docker"],"fromNow":"a year ago"},"content":"\nDocker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n\nimage 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。\n\n```shell\n# 列出本机的所有 image 文件。\n$ docker image ls\n\n# 删除 image 文件\n$ docker image rm [imageName]\n```\n\nimage 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。\n\n为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。\n\n## 更多\n","slug":"docker/Docker镜像"}]},"__N_SSG":true}