{"pageProps":{"data":{"date":"April 4, 2021","title":"操作符、条件判断","tags":["swift"],"description":"取得成功的秘诀就是开始","fromNow":"8 months ago"},"content":{"compiledSource":"var s=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var l=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,r=(e,t)=>{for(var a in t||(t={}))l.call(t,a)&&p(e,a,t[a]);if(n)for(var a of n(t))i.call(t,a)&&p(e,a,t[a]);return e},u=(e,t)=>d(e,m(t));var c=(e,t)=>{var a={};for(var o in e)l.call(e,o)&&t.indexOf(o)<0&&(a[o]=e[o]);if(e!=null&&n)for(var o of n(e))t.indexOf(o)<0&&i.call(e,o)&&(a[o]=e[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:e}=o,t=c(o,[\"components\"]);return mdx(MDXLayout,u(r(r({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Swift \\u6709\\u4E09\\u79CD\\u6761\\u4EF6\\u5224\\u65AD\\uFF1A\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"if else\"),mdx(\"li\",{parentName:\"ul\"},\"switch\"),mdx(\"li\",{parentName:\"ul\"},\"ternary \",mdx(\"inlineCode\",{parentName:\"li\"},\"\\u4E09\\u5143\\u8FD0\\u7B97\"))),mdx(\"h3\",null,\"if else\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"if \\u8BED\\u53E5 \\u540E\\u53EF\\u4EE5\\u6709\\u53EF\\u9009\\u7684 else \\u8BED\\u53E5, else \\u8BED\\u53E5\\u5728\\u5E03\\u5C14\\u8868\\u8FBE\\u5F0F\\u4E3A false \\u65F6\\u6267\\u884C\\u3002\")),mdx(\"p\",null,mdx(\"img\",r({parentName:\"p\"},{src:\"https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/XxhyS1.png\",alt:\"XxhyS1\"}))),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-swift\"}),`let level = 9001\nif level > 9000 {\n  print(\"It's over 9000! You can proceed with your quest.\")\n} else {\n  print(\"Bummer, you definitely need to go for a training arc\")\n}\n`)),mdx(\"h3\",null,\"switch\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"switch \\u8BED\\u53E5\\u5141\\u8BB8\\u6D4B\\u8BD5\\u4E00\\u4E2A\\u53D8\\u91CF\\u7B49\\u4E8E\\u591A\\u4E2A\\u503C\\u65F6\\u7684\\u60C5\\u51B5\\u3002\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-swift\"}),`let level = 10000\n\nswitch level {\n   case 7000 :\n     print(\"Muda Muda Muda Muda Muda Muda\")\n   case 8000 :\n     print(\"You are not strong enough\")\n   case 9000 :\n     print(\"You are strong enough! You can proceed with your quest\")\n   case 10000:\n     print(\"It's over 9000! You can proceed with your quest.\")\n   default :\n     print(\"Please try again\")\n}\n`)),mdx(\"h3\",null,\"ternary\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"switch \\u8BED\\u53E5\\u5141\\u8BB8\\u6D4B\\u8BD5\\u4E00\\u4E2A\\u53D8\\u91CF\\u7B49\\u4E8E\\u591A\\u4E2A\\u503C\\u65F6\\u7684\\u60C5\\u51B5\\u3002 Swift \\u8BED\\u8A00\\u4E2D \\b \\u53EA\\u8981\\u5339\\u914D\\u5230 case \\u8BED\\u53E5\\uFF0C\\u5219\\u6574\\u4E2A switch \\u8BED\\u53E5\\u6267\\u884C\\u5B8C\\u6210\\u3002\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-swift\"}),`let level = 9000\nprint( level > 9000 ? \"It's over 9000! You can proceed with your quest.\" :  print(\"Bummer, you definitely need to go for a training arc\")\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"April 4, 2021","title":"操作符、条件判断","tags":["swift"],"description":"取得成功的秘诀就是开始","fromNow":"8 months ago"}},"randomPost":[{"data":{"date":"April 11, 2021","title":"闭包","tags":["swift"],"description":"闭包(Closures)是自包含的功能代码块，可以在代码中使用或者用来作为参数传值。","fromNow":"8 months ago"},"content":"\n## 闭包的定义\n\n闭包(Closures)是自包含的功能代码块，可以将闭包视为无名函数，可以将其分配给变量或将其作为参数传递给函数。\n闭包主要用于在将来满足条件时执行某项操作。例如，成功下载文件后，将其内容存储到数据库中。\n\n全局函数和嵌套函数其实就是特殊的闭包。\n\n闭包的形式有：\n\n| 全局函数               | 嵌套函数                       | 闭包表达式                                         |\n| ---------------------- | ------------------------------ | -------------------------------------------------- |\n| 有名字但不能捕获任何值 | 有名字，也能捕获封闭函数内的值 | 无名闭包，使用轻量级语法，可以根据上下文环境捕获值 |\n\n## 创建闭包\n\n```swift\nlet helloWorldClosure = {\n  print(\"hello\")\n}\n\nhelloWorldClosure()\n```\n\n上面的代码创建一个打印`Hello`的闭包，并将该闭包分配给`helloWorldClosure`变量。然后，可以像调用函数一样简单地调用闭包。\n\n## 接收参数\n\n```swift\nlet driving = { (place: String) in\n    print(\"I'm going to \\(place) in my car\")\n}\ndriving(\"London\")\n```\n\n## 闭包返回值\n\n```swift\nlet addClosure = { (first: Int, second: Int) -> Int in\n    return first + second\n}\n\nlet sum = addClosure(1,2)\n```\n\n上面的代码创建一个以两个数字为参数的闭包，并返回数字的总和。\n\n## 作为参数传递\n\n```swift\nlet saveFile = {\n   //code to save file\n}\n\nfunc downloadFile(imageUrl, onSuccess: () ->) {\n  //code to download file\n  if(downloadSuccessfull){\n     onSuccess()\n  }\n}\n\ndownloadFile(imageUrl: \"Instagram\", onSuccess: saveFile)\n```\n\n上面的代码创建了一个闭包，用于保存从`Internet`下载的文件。这个闭包被传递到`downloadFile`函数中。此`downloadFile`功能从互联网下载文件，如果文件下载成功，则调用保存文件关闭。\n","slug":"swift/100days/day06"},{"data":{"date":"July 30, 2017","title":"css的小技巧","tags":["css"],"fromNow":"4 years ago"},"content":"\n1. 使用 CSS 复位\n\n不同浏览器有不同的自带初始样式，通常可以使用 normalize.css、tinyreset.css 进行通配初始化。\n\n```css\n*,\n*:after,\n*:before {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n```\n\n2. 继承 box-sizing\n\n```css\nhtml {\n  box-sizing: border-box;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: inherit;\n}\n```\n\n3. 使用 unset 而不是重置所有属性\n4. 使用 :not() 选择器来决定表单是否显示边框\n5. 为 body 元素添加行高\n6. 為表單元素設置:focus\n7. 垂直居中任何元素\n8. 逗号分隔的列表\n9. 使用负的 nth-child 来选择元素\n10. 使用 SVG 图标\n11. 使用 “形似猫头鹰” 的选择器\n12. 使用 max-height 来建立纯 CSS 的滑块\n13. 创造格子等宽的表格\n14. 利用 Flexbox 去除多余的外边距\n15. 利用属性选择器来选择空链接\n16. 给 “默认” 链接定义样式\n17. 一致的垂直节奏\n18. 内在比例盒\n19. 为破碎图象定义样式\n20. 用 rem 来调整全局大小；用 em 来调整局部大小\n21. 隐藏没有静音、自动播放的影片\n22. 使用选择器 :root 来控制字体弹性\n23. 为更好的移动体验，为表单元素设置字体大小\n24. 使用指针事件來控制鼠标事件\n","slug":"css/小技巧-ChicksTricks"},{"data":{"date":"April 12, 2021","title":"什么是React","tags":["react","javascript"],"description":"React是一个JavaScript库，致力于使UI开发变得简单","fromNow":"8 months ago"},"content":"\n![xCOR7k](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/xCOR7k.jpg)\n\nReact 最初是由 Facebook 开发的，旨在解决他们面临的前端问题：\n\n1. DOM 操作是极其昂贵的\n\n2. 当时没有专门处理前端库的库（Angular）\n\n3. 使用大量 jQuery 会导致代码混乱而且难以理解\n\n2013 年，React 以开源库的形式发布，从那时起，它就受到了社区的广泛喜爱。\n\n为什么开发人员喜欢 React？总结有几个原因：\n\n启动 React 很简单，运行 React 并不容易，因为它使用 JavaScript 渲染视图。你需要了解 Webpack 及其配置，需要了解 babel、eslint 等。但是 Facebook 为我们提供了`create-react-app`，可以快速开始 react 开发。\n\n从本质上讲，这是极简主义的，React 只处理一件事：UI。我们可以将 React 视为 MVC 框架中的`V`。\n\n强大的社区支持为了增强 React 的功能，开源贡献者已经建立了一个令人惊叹的库生态系统，使我们能够开发更强大的应用程序。\n\n最重要的是，React 的学习曲线很小，可为提供令人难以置信的强大功能，UI 灵活，可重用和可控制。\n\nReact 中必须掌握的核心概念：\n\n- 组件`component`\n- jsx\n- 状态`state`\n- 属性`props`\n\n## 入门\n\n创建一个简单的 React 应用\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Simple React.js application</title>\n  </head>\n  <body>\n    <h2>Simple React.js application</h2>\n\n    <div id=\"show_button_container\"></div>\n\n    <script\n      src=\"https://unpkg.com/react@16/umd/react.development.js\"\n      crossorigin\n    ></script>\n    <script\n      src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"\n      crossorigin\n    ></script>\n\n    <script>\n      'use strict';\n      const e = React.createElement;\n\n      class ShowButton extends React.Component {\n        render() {\n          return e('button', { onClick: () => alert('Hello there!') }, 'Show');\n        }\n      }\n\n      const domContainer = document.querySelector('#show_button_container');\n      ReactDOM.render(e(ShowButton), domContainer);\n    </script>\n  </body>\n</html>\n```\n","slug":"react/什么是react"},{"data":{"date":"November 20, 2021","title":"如何在 vue 中使用 Debounce、Throttle","tags":["vue","javascript"],"description":"如input、resize、scroll、intersection observer 等事件可能发生得非常频繁，例如每秒发生几次，因此调用一个动作，比如对每个事件发出读取请求，并不是一个明智的方法。","fromNow":"25 days ago"},"content":"\n## 为什么要使用 debounce 和 throttle\n\n防抖和节流就是针对响应跟不上触发频率这类问题的两种解决方案。在给 DOM 绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件 onmousemove, 滚动滚动条事件 onscroll，窗口大小改变事件 onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定 onkeyup 事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\n\n## 在 watcher 中使用 debounce\n\n1. 在`created`生命周期将`this.debounce`绑定到`this`上，这样`this.debounce`就可以在`created`生命周期中使用。\n2. 在`watch`函数中，使用`this.debounce`调用`debounce`函数，并传入`this.debounce`的回调函数。\n3. 在事件销毁前，使用`this.debounce`调用`clear`函数，清除定时器。\n\n```html\n<template>\n  <input v-model=\"value\" type=\"text\" />\n  <p>{{ value }}</p>\n</template>\n<script>\n  import debounce from 'lodash.debounce';\n  export default {\n    data() {\n      return {\n        value: '',\n      };\n    },\n    watch: {\n      value(...args) {\n        this.debouncedWatch(...args);\n      },\n    },\n    created() {\n      this.debouncedWatch = debounce((newValue, oldValue) => {\n        console.log('New value:', newValue);\n      }, 500);\n    },\n    beforeUnmount() {\n      this.debouncedWatch.cancel();\n    },\n  };\n</script>\n```\n\n## 使用 debounce 处理事件\n\n```html\n<template>\n  <input v-on:input=\"debouncedHandler\" type=\"text\" />\n</template>\n<script>\n  import debounce from 'lodash.debounce';\n  export default {\n    created() {\n      this.debouncedHandler = debounce((event) => {\n        console.log('New value:', event.target.value);\n      }, 500);\n    },\n    beforeUnmount() {\n      this.debouncedHandler.cancel();\n    },\n  };\n</script>\n```\n\n为什么不适用`debounce`或`throttle`直接绑定函数呢？比如：\n\n```html\n<template>\n  <input v-on:input=\"debouncedHandler\" type=\"text\" />\n</template>\n<script>\n  import debounce from 'lodash.debounce';\n  export default {\n    methods: {\n      // Don't do this!\n      debouncedHandler: debounce(function (event) {\n        console.log('New value:', event.target.value);\n      }, 500),\n    },\n  };\n</script>\n```\n\n**使用`export default { ... }`从组件导出的 options 对象，包括方法，将被组件的所有实例重用。如果网页中有 2 个或更多的组件实例，那么所有的组件都将使用相同的`debounce`或`throttle`的函数方法。**\n\n## 总结\n\n在 `vue` 中使用 `debounce` 和 `throttle` 函数，应该在 `created` 和 `beforeUnmount` 生命周期中使用，而不是在 `watch` 中使用。\n\n```html\n<template>\n  <input v-on:input=\"debouncedHandler\" type=\"text\" />\n</template>\n<script>\n  export default {\n    created() {\n      this.debouncedCallback = debounce((...args) => {\n        // The debounced\n        callback;\n      }, 500);\n    },\n    watch: {\n      value(...args) {\n        this.debouncedCallback(...args);\n      },\n    },\n  };\n</script>\n```\n","slug":"vue/debounce-throttle"},{"data":{"date":"May 19, 2020","title":"闭包","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 什么是闭包\n\n作用：能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。\n\n原理：基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到\n\n```javascript\nfunction foo() {\n  var a = 'hzfe';\n  function bar() {\n    console.log(a);\n  }\n  return bar;\n}\n\nvar baz = foo();\nbaz(); // hzfe\n```\n\n在这个例子中，函数 bar 作为返回值返回后，在自己定义的词法作用域以外的地方执行。一般来说，在函数 foo 执行后，通常会期待函数 foo 的整个内部作用域被引擎回收机制销毁。而闭包可以阻止这件事情的发生。事实上内部作用域依然存在，因为函数 bar 本身在使用，所以并不会被回收。\n\n在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n## 闭包的应用\n\n无论何时何地，如果将函数作为返回值，就会看到闭包在这些函数中的应用。在定时器，事件监听器，ajax 请求，跨窗口通信，web workers 或者任何其他的异步/同步任务中，只要使用了回调函数，实际上就是使用闭包。使用闭包的例子可以参考实现节流防抖函数。\n\n```javascript\nvar a = 'hzfe';\n(function IIFE() {\n  console.log(a);\n})();\n```\n\n通常认为立即执行函数（IIFE）是典型的观察闭包的典型例子，但严格来说并不是。虽然创建了闭包，但没有体现出闭包的作用。因为函数并不是在它本身的词法作用域以外执行的。 它在定义时所在的作用域中执行，而非外部作用域。\n\n## 扩展\n\n- [闭包 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)\n- [垃圾回收机制](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Closed_Overlay_Requires_Arguments)\n- [你不知道的 JavaScript](https://www.imooc.com/article/2907)\n","slug":"javascript/advance/闭包"},{"data":{"date":"December 19, 2019","title":"JS概念扩展","tags":["i18n","javascript"],"fromNow":"2 years ago"},"content":"\n## 原始值和引用值\n\n> 了解如何将对象，数组和函数复制并传递给函数。要知道引用时复制了什么。理解原始值是通过复制值来进行复制和传递的。\n\n## 作用域\n\n> 了解全局作用域，函数作用域和块作级用域之间的区别。了解哪些变量在哪些地方可用。知道 JavaScript 引擎如何执行变量查找。\n\n## 提升\n\n> 理解变量和函数声明会被提升到可用作用域的顶部。 理解函数表达式不会被提升。\n\n## 闭包\n\n> 知道一个函数保留，并且可以访问创建它的作用域。知道这些可以让我们做什么，例如数据隐藏、内存化以及动态函数生成。\n\n## this\n\n> 知道 this 绑定的规则。知道它的工作机制，知道如何弄清楚在一个函数中它等同于什么，或者说指向什么？并知道为什么它是有用的。\n\n## new\n\n> 知道它如何与面向对象编程相关。知道用 new 调用的函数会发生什么。理解如何使用 new 来继承函数 prototype(原型) 属性生成的对象。\n\n## apply、call、bind\n\n> 知道这些函数的工作机制。 知道如何使用它们。了解它们对 this 做了什么。\n\n## 原型和继承\n\n> 了解 JavaScript 中的继承是通过 [[Prototype]] 链实现的。了解如何通过函数和对象来设置继承，以及 new 是如何帮助我们实现的。知道 **proto** 和 prototype 属性是什么，以及他们的作用。\n\n## 异步和同步\n\n> 理解事件循环，理解浏览器是如何处理用户输入、Web 请求和一般事件的。知道如何识别并正确实现异步代码。理解 JavaScript 中异步和单线程分别是怎样的。\n\n## 高阶函数\n\n> 理解这些函数是 JavaScript 中的一等公民，以及这意味着什么。 知道从另一个函数返回一个函数是完全合法的。 了解闭包和更高阶函数允许我们使用的技巧\n","slug":"translate/概念扩展"}]},"__N_SSG":true}