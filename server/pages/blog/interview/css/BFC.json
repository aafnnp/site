{"pageProps":{"data":{"date":"October 19, 2020","title":"css-BFC","tags":["css"],"fromNow":"a year ago"},"content":{"compiledSource":"var N=Object.defineProperty,s=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var r=(l,e,i)=>e in l?N(l,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):l[e]=i,t=(l,e)=>{for(var i in e||(e={}))o.call(e,i)&&r(l,i,e[i]);if(n)for(var i of n(e))p.call(e,i)&&r(l,i,e[i]);return l},u=(l,e)=>s(l,C(e));var m=(l,e)=>{var i={};for(var a in l)o.call(l,a)&&e.indexOf(a)<0&&(i[a]=l[a]);if(l!=null&&n)for(var a of n(l))e.indexOf(a)<0&&p.call(l,a)&&(i[a]=l[a]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var a=i,{components:l}=a,e=m(a,[\"components\"]);return mdx(MDXLayout,u(t(t({},layoutProps),e),{components:l,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"\\u4EC0\\u4E48\\u662F BFC\"),mdx(\"p\",null,\"Block Formatting Context\\uFF08\\u5757\\u7EA7\\u683C\\u5F0F\\u5316\\u4E0A\\u4E0B\\u6587\\uFF09\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"Web \\u9875\\u9762\\u7684\\u53EF\\u89C6 CSS \\u6E32\\u67D3\\u7684\\u4E00\\u90E8\\u5206\\uFF0C\\u662F\\u5757\\u76D2\\u5B50\\u7684\\u5E03\\u5C40\\u8FC7\\u7A0B\\u53D1\\u751F\\u7684\\u533A\\u57DF\\uFF0C\\u4E5F\\u662F\\u6D6E\\u52A8\\u5143\\u7D20\\u4E0E\\u5176\\u4ED6\\u5143\\u7D20\\u4EA4\\u4E92\\u7684\\u533A\\u57DF\")),mdx(\"h2\",null,\"\\u5E03\\u5C40\\u89C4\\u5219\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\u5185\\u90E8\\u7684 Box \\u4F1A\\u5728\\u5782\\u76F4\\u65B9\\u5411\\u4E00\\u4E2A\\u63A5\\u4E00\\u4E2A\\u5730\\u653E\\u7F6E\"),mdx(\"li\",{parentName:\"ul\"},\"Box \\u5782\\u76F4\\u65B9\\u5411\\u7684\\u8DDD\\u79BB\\u7531 margin \\u51B3\\u5B9A\\u3002\\u5C5E\\u4E8E\\u540C\\u4E00\\u4E2A BFC \\u7684\\u4E24\\u4E2A\\u76F8\\u90BB Box \\u7684 margin \\u4F1A\\u53D1\\u751F\\u91CD\\u53E0\"),mdx(\"li\",{parentName:\"ul\"},\"\\u6BCF\\u4E2A\\u76D2\\u5B50\\uFF08\\u5757\\u76D2\\u4E0E\\u884C\\u76D2\\uFF09\\u7684 margin box \\u7684\\u5DE6\\u8FB9\\uFF0C\\u4E0E\\u5305\\u542B\\u5757 border box \\u7684\\u5DE6\\u8FB9\\u76F8\\u63A5\\u89E6\\uFF0C\\u5373\\u4F7F\\u5B58\\u5728\\u6D6E\\u52A8\\u4E5F\\u662F\\u5982\\u6B64\"),mdx(\"li\",{parentName:\"ul\"},\"BFC \\u7684\\u533A\\u57DF\\u4E0D\\u4F1A\\u4E0E float box \\u91CD\\u53E0\"),mdx(\"li\",{parentName:\"ul\"},\"BFC \\u5C31\\u662F\\u9875\\u9762\\u4E0A\\u7684\\u4E00\\u4E2A\\u9694\\u79BB\\u7684\\u72EC\\u7ACB\\u5BB9\\u5668\\uFF0C\\u5BB9\\u5668\\u91CC\\u9762\\u7684\\u5B50\\u5143\\u7D20\\u4E0D\\u4F1A\\u5F71\\u54CD\\u5916\\u9762\\u7684\\u5143\\u7D20\\u3002\\u53CD\\u4E4B\\u4E5F\\u662F\\u5982\\u6B64\"),mdx(\"li\",{parentName:\"ul\"},\"\\u8BA1\\u7B97 BFC \\u7684\\u9AD8\\u5EA6\\u65F6\\uFF0C\\u6D6E\\u52A8\\u5143\\u7D20\\u4E5F\\u53C2\\u4E0E\\u8BA1\\u7B97\")),mdx(\"h2\",null,\"\\u5982\\u4F55\\u521B\\u5EFA BFC\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\u6839\\u5143\\u7D20\\u6216\\u5176\\u4ED6\\u5305\\u542B\\u4ED6\\u7684\\u5143\\u7D20\"),mdx(\"li\",{parentName:\"ul\"},\"\\u6D6E\\u52A8\\u5143\\u7D20\\uFF08\\u5143\\u7D20\\u7684 float \\u4E0D\\u662F none\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},\"\\u7EDD\\u5BF9\\u5B9A\\u4F4D\\u5143\\u7D20\\uFF08\\u5143\\u7D20\\u5177\\u6709 position \\u4E3A absolute \\u6216 fixed\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},\"\\u5185\\u8054\\u5757\\uFF08\\u5143\\u7D20\\u5177\\u6709 display: inline-block\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},\"\\u8868\\u683C\\u5355\\u5143\\u683C\\uFF08\\u5143\\u7D20\\u5177\\u6709 display: table-cell \\uFF0CHTML \\u8868\\u683C\\u5355\\u5143\\u683C\\u9ED8\\u8BA4\\u5C5E\\u6027\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},\"\\u8868\\u683C\\u6807\\u9898\\uFF08\\u5143\\u7D20\\u5177\\u6709 display: table-caption\\uFF0CHTML \\u8868\\u683C\\u6807\\u9898\\u9ED8\\u8BA4\\u5C5E\\u6027\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},\"\\u5177\\u6709 overflow \\u4E14\\u503C\\u4E0D\\u662F visible \\u7684\\u5757\\u5143\\u7D20\"),mdx(\"li\",{parentName:\"ul\"},\"\\u5F39\\u6027\\u76D2\\u5B50\\uFF08flex \\u6216 inline-flex\\uFF09\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\" css display: flow-root\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"css column-span: all\"))),mdx(\"h2\",null,\"BFC \\u4F5C\\u7528\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\u5229\\u7528 BFC \\u907F\\u514D margin \\u91CD\\u53E0\"),mdx(\"li\",{parentName:\"ul\"},\"\\u81EA\\u9002\\u5E94\\u4E24\\u680F\\u5E03\\u5C40\"),mdx(\"li\",{parentName:\"ul\"},\"\\u6E05\\u9664\\u6D6E\\u52A8\")))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"October 19, 2020","title":"css-BFC","tags":["css"],"fromNow":"a year ago"}},"randomPost":[{"data":{"date":"May 19, 2020","title":"原型和原型链","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n![Dyv0vb](https://cdn.jsdelivr.net/gh/funnyPan/pics@master/uPic/Dyv0vb.jpg)\n\n每个对象都会在其内部初始化⼀个属性，就是`prototype`(原型)，当我们访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去`prototype` ⾥找这个属性，这个`prototype`⼜会有⾃⼰的`prototype`，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念关系：`instance.constructor.prototype = instance.__proto__` 特点： JavaScript 对象是通过引⽤来传递的，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的`Prototype`对象是否有这个属性，如此递推下去，⼀直检索到`Object`内建对象\n\n## 原型：\n\nJavaScript 的所有对象中都包含了⼀个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型\n\nJavaScript 的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型[__proto__] 。\n\n## 原型链：\n\n当⼀个对象调⽤的属性/⽅法⾃身不存在时，就会去⾃⼰ [__proto__] 关联的前辈 prototype 对象上去找如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/⽅法或 undefined 为⽌。从⽽形成了所谓的“原型链”\n\n## 原型特点：\n\nJavaScript 对象是通过引⽤来传递的，当修改原型时，与之相关的对象也会继承这⼀改变\n","slug":"javascript/advance/原型和原型链"},{"data":{"date":"May 19, 2020","title":"继承","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 构造继承\n\n## 原型继承\n\n## 实例继承\n\n## 拷⻉继承\n\n## 原型 prototype 机制或 apply 和 call ⽅法去实现较简单，建议使⽤构造函数与原型混合⽅式\n\n```javascript\nfunction Parent() {\n  this.name = 'wang';\n}\nfunction Child() {\n  this.age = 28;\n}\nChild.prototype = new Parent(); //继承了Parent，通过原型\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name); //得到被继承的属性\n```\n","slug":"javascript/advance/js的继承"},{"data":{"date":"May 19, 2020","title":"类型判断","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## typeof\n\n> 用于判断操作数的数据类型，适用于除 null、object 的其他 5 种类型的判断。\n\n1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n2. 对于引用类型，除 function 以外，一律返回 object 类型。\n3. 对于 null ，返回 object 类型。\n4. 对于 function 返回 function 类型。\n\n```javascript\ntypeof undefined; // \"undefined\";\ntypeof 1; // \"number\";\ntypeof '1'; // \"string\";\ntypeof true; // \"boolean\";\ntypeof Symbol(); // \"symbol\";\ntypeof { a: 1 }; // \"object\";\n\ntypeof null === 'object'; // true\ntypeof function () {} === 'function'; // true\n```\n\n## instanceof\n\n> 用于判断是对象的那个子类型\n\n```javascript\n[1, 2] instanceof Array; // true\n(function foo() {} instanceof Function); // true\nnew Date(2018) instanceof Date; // true\nnew Number(1) instanceof Number; // true\n1 instanceof Number; // false\n```\n\na instanceof b，instanceof 会去查找 a 的原型链(这里不展开讨论)上是否有 b 的 prototype 属性；如果有，就返回 true，否则返回 false。即判断 a 的原型链上是否有 a.\\_proto\\_\\_ === b.prototype 返回 true\n\n## constructor\n\n> 不仅可以用于对象子类型的判断，还可以用于基本类型的判断，返回创建实例对象的 Object 构造函数的引用，原始数据类型，constructor 只读，基本类型指向对应的内置对象的构造函数\n\n```javascript\n({ a: 1 }.constructor === Object); // true\n[1, 2].constructor === Array; // true\nnew Date(2018).constructor === Date; // true\n(function foo() {}.constructor === Function); // true\n'1'.constructor === String; // true\n(1).constructor === Number; // true\ntrue.constructor === Boolean; // true\n```\n\n## prototype\n\n> Object.prototype.toString.call('...')，通用方法判断对象类型。 Object.prototype 表示 Object 的原型对象，toString 返回表示该对象的字符串，call 用于指定 this\n\n```javascript\nObject.prototype.toString.call('1'); // \"[object String]\"\nObject.prototype.toString.call(1); // \"[object Number]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call([1, 2, 3]); // \"[object Array]\"\nObject.prototype.toString.call(function foo() {}); // \"[object Function]\"\nObject.prototype.toString.call(null); //\"[object Null]\"\nObject.prototype.toString.call(undefined); //\"[object Undefined]\"\n```\n","slug":"javascript/advance/类型判断"},{"data":{"date":"December 19, 2019","title":"JS概念扩展","tags":["i18n","javascript"],"fromNow":"2 years ago"},"content":"\n## 原始值和引用值\n\n> 了解如何将对象，数组和函数复制并传递给函数。要知道引用时复制了什么。理解原始值是通过复制值来进行复制和传递的。\n\n## 作用域\n\n> 了解全局作用域，函数作用域和块作级用域之间的区别。了解哪些变量在哪些地方可用。知道 JavaScript 引擎如何执行变量查找。\n\n## 提升\n\n> 理解变量和函数声明会被提升到可用作用域的顶部。 理解函数表达式不会被提升。\n\n## 闭包\n\n> 知道一个函数保留，并且可以访问创建它的作用域。知道这些可以让我们做什么，例如数据隐藏、内存化以及动态函数生成。\n\n## this\n\n> 知道 this 绑定的规则。知道它的工作机制，知道如何弄清楚在一个函数中它等同于什么，或者说指向什么？并知道为什么它是有用的。\n\n## new\n\n> 知道它如何与面向对象编程相关。知道用 new 调用的函数会发生什么。理解如何使用 new 来继承函数 prototype(原型) 属性生成的对象。\n\n## apply、call、bind\n\n> 知道这些函数的工作机制。 知道如何使用它们。了解它们对 this 做了什么。\n\n## 原型和继承\n\n> 了解 JavaScript 中的继承是通过 [[Prototype]] 链实现的。了解如何通过函数和对象来设置继承，以及 new 是如何帮助我们实现的。知道 **proto** 和 prototype 属性是什么，以及他们的作用。\n\n## 异步和同步\n\n> 理解事件循环，理解浏览器是如何处理用户输入、Web 请求和一般事件的。知道如何识别并正确实现异步代码。理解 JavaScript 中异步和单线程分别是怎样的。\n\n## 高阶函数\n\n> 理解这些函数是 JavaScript 中的一等公民，以及这意味着什么。 知道从另一个函数返回一个函数是完全合法的。 了解闭包和更高阶函数允许我们使用的技巧\n","slug":"translate/概念扩展"},{"data":{"date":"December 2, 2021","title":"Functions","tags":["python"],"description":"随着程序的不断更新，我们会发现，函数的定义和调用是一致的。","fromNow":"12 days ago"},"content":"\n## 函数的定义\n\n函数的定义是一个特殊的可复用的代码块，它的第一行必须是函数的声明，第二行开始是函数的实现。\n\n```python\n#定义函数\ndef sumcount(n):\n    '''\n    Returns the sum of the first n integers\n    '''\n    total = 0\n    while n > 0:\n        total += n\n        n -= 1\n    return total\n#调用函数\na = sumcount(100)\n```\n\n## 标准函数\n\npython 中的标准函数是一些内置的函数，通过`import`调用。\n\n```python\nimport math\nx = math.sqrt(10)\n\nimport urllib.request\nu = urllib.request.urlopen('http://www.python.org/')\ndata = u.read()\n```\n\n## 错误和异常\n\n错误和异常是 python 中的两个主要概念，错误是指程序运行过程中发生的错误，异常是指程序运行过程中抛出的异常。例如：\n\n```python\n>>> int('N/A')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: 'N/A'\n>>>\n```\n\n## 捕获、处理异常\n\n异常可以通过`try`和`except`来捕获，也可以通过`try`和`finally`来处理。\n\n```python\nfor line in f:\n    fields = line.split()\n    try:\n        shares = int(fields[1])\n    except ValueError:\n        print(\"Couldn't parse\", line)\n    ...\n```\n","slug":"python/1.6-function"},{"data":{"date":"November 20, 2021","title":"Numbers","tags":["python"],"description":"关于数学运算","fromNow":"25 days ago"},"content":"\n## Numbers 类型\n\n> python 有 4 种数字类型\n\n- Boolean\n- Integer\n- Float\n- Complex\n\n### Boolean\n\n布尔值，只有 True 和 False 两个值，可以用来表示真假。\n\n```python\na=True\nb=False\n```\n\n在数学运算种，布尔值的值只有 0 和 1，0 表示 False，1 表示 True。\n\n```python\nc=4+True #5\nd=False\nif d==0:\n    print('d is zero')\nelse:\n    print('d is not zero')\n```\n\n### Integer\n\n```python\na = 37\nb = -299392993727716627377128481812241231\nc = 0x7fa8      # Hexadecimal\nd = 0o253       # Octal\ne = 0b10001111  # Binary\n```\n\n### Float\n\n```python\n>>> a = 2.1 + 4.2\n>>> a == 6.3\nFalse\n>>> a\n6.300000000000001\n>>>\n```\n\n### 比较 Comparisons\n\npython 有如下比较运算符：\n\n```python\nx < y      Less than\nx <= y     Less than or equal\nx > y      Greater than\nx >= y     Greater than or equal\nx == y     Equal to\nx != y     Not equal to\n\n#布尔值操作\nif b >= a and b <= c:\n    print('b is between a and c')\n\nif not (b < a or b > c):\n    print('b is still between a and c')\n```\n\n### 数字转换\n\n使用类型名转换数字，如下：\n\n```python\na = int(3.14)\nb = float(3)\n```\n","slug":"python/1.2-numbers"}]},"__N_SSG":true}