{"pageProps":{"data":{"date":"January 8, 2021","title":"基于Docker镜像的更新","tags":["docker"],"fromNow":"a year ago"},"content":{"compiledSource":"var d=Object.defineProperty,i=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,t=Object.prototype.propertyIsEnumerable;var m=(e,a,o)=>a in e?d(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,r=(e,a)=>{for(var o in a||(a={}))p.call(a,o)&&m(e,o,a[o]);if(n)for(var o of n(a))t.call(a,o)&&m(e,o,a[o]);return e},s=(e,a)=>i(e,u(a));var c=(e,a)=>{var o={};for(var l in e)p.call(e,l)&&a.indexOf(l)<0&&(o[l]=e[l]);if(e!=null&&n)for(var l of n(e))a.indexOf(l)<0&&t.call(e,l)&&(o[l]=e[l]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var l=o,{components:e}=l,a=c(l,[\"components\"]);return mdx(MDXLayout,s(r(r({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"\\u505C\\u6B62\\u955C\\u50CF\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`docker stop <ID or name>\n`)),mdx(\"ol\",r({},{start:2}),mdx(\"li\",{parentName:\"ol\"},\"\\u79FB\\u9664\\u955C\\u50CF\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`docker rm <ID or name>\n`)),mdx(\"ol\",r({},{start:3}),mdx(\"li\",{parentName:\"ol\"},\"\\u62C9\\u53D6\\u6700\\u65B0\\u955C\\u50CF\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`docker pull <image name>\n`)),mdx(\"ol\",r({},{start:4}),mdx(\"li\",{parentName:\"ol\"},\"\\u542F\\u52A8\\u955C\\u50CF\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-shell\"}),`docker run <image name> ...options\n`)),mdx(\"h2\",null,\"\\u66F4\\u591A\"))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"January 8, 2021","title":"基于Docker镜像的更新","tags":["docker"],"fromNow":"a year ago"}},"randomPost":[{"data":{"date":"December 21, 2020","title":"Macos Docker安装","tags":["docker"],"fromNow":"a year ago"},"content":"\n## brew 安装 docker\n\n```shell\n#搜索\n==> Formulae\ndocker                          docker-credential-helper        docker-machine-completion       docker-machine-nfs              docker2aci\ndocker-clean                    docker-credential-helper-ecr    docker-machine-driver-hyperkit  docker-machine-parallels        dockerize\ndocker-completion               docker-gen                      docker-machine-driver-vmware    docker-slim                     lazydocker\ndocker-compose                  docker-ls                       docker-machine-driver-vultr     docker-squash\ndocker-compose-completion       docker-machine                  docker-machine-driver-xhyve     docker-swarm\n==> Casks\ndocker\n\n#安装\nbrew install docker\n==> Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/docker-19.03.14.big_sur.bottle.tar.gz\n######################################################################## 100.0%\n==> Pouring docker-19.03.14.big_sur.bottle.tar.gz\n==> Caveats\nzsh completions have been installed to:\n  /usr/local/share/zsh/site-functions\n==> Summary\n🍺  /usr/local/Cellar/docker/19.03.14: 14 files, 71.6MB\n```\n\n## 手动安装\n\n下载[Stable](https://download.docker.com/mac/stable/Docker.dmg)，双击安装\n\n![PVr5uh](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/PVr5uh.jpg)\n\n安装完成后，通过命令检查 Docker 版本\n\n```shell\ndocker --version\n\nDocker version 19.03.14, build 5eb3275\n```\n\n## 镜像加速\n\n![NAWFnd](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/NAWFnd.png)\n\n## 更多\n","slug":"docker/Macos安装Docker"},{"data":{"date":"October 19, 2020","title":"css-BFC","tags":["css"],"fromNow":"a year ago"},"content":"\n## 什么是 BFC\n\nBlock Formatting Context（块级格式化上下文）\n\n> Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n\n## 布局规则\n\n- 内部的 Box 会在垂直方向一个接一个地放置\n- Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n- 每个盒子（块盒与行盒）的 margin box 的左边，与包含块 border box 的左边相接触，即使存在浮动也是如此\n- BFC 的区域不会与 float box 重叠\n- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的元素。反之也是如此\n- 计算 BFC 的高度时，浮动元素也参与计算\n\n## 如何创建 BFC\n\n- 根元素或其他包含他的元素\n- 浮动元素（元素的 float 不是 none）\n- 绝对定位元素（元素具有 position 为 absolute 或 fixed）\n- 内联块（元素具有 display: inline-block）\n- 表格单元格（元素具有 display: table-cell ，HTML 表格单元格默认属性）\n- 表格标题（元素具有 display: table-caption，HTML 表格标题默认属性）\n- 具有 overflow 且值不是 visible 的块元素\n- 弹性盒子（flex 或 inline-flex）\n- ` css display: flow-root`\n- `css column-span: all`\n\n## BFC 作用\n\n- 利用 BFC 避免 margin 重叠\n- 自适应两栏布局\n- 清除浮动\n","slug":"interview/css/BFC"},{"data":{"date":"March 11, 2019","title":"Promise","tags":["javascript"],"fromNow":"3 years ago"},"content":"\n## Promise\n\n> 用于一个异步操作的最终完成或失败及其结果\n\n## 状态\n\n1. pending，初识状态\n2. fulfilled，操作成功\n3. rejected，操作失败\n\n## 流程\n\n![](https://cdn.jsdelivr.net/gh/funnypan/pics@master/img/20190830101852.png)\n\n## 语法\n\n```javascript\nnew Promise((resolve, reject) => {\n  /*executor*/\n});\n```\n\n> Promise 执行时立即调用 executor 函数（通常是一些异步操作），resovle 将 Promise 的状态改为 fulfilled，reject 将 Promise 的状态改为 rejected，如果 catch 到了错误，将忽略 executor 内的返回值，Promise 的状态被改成 rejected\n\n## 属性\n\n1. Promise.length //1\n2. Promise.prototype //Promise 的构造器的原型\n\n## 方法\n\n1. Promise.all //Promise.all 方法常被用于处理多个 promise 对象的状态集合\n2. Promise.race //当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。\n3. Promise.reject //返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法\n4. Promise.resolve //返回的 Promise 对象状态为 fulfilled\n\n## 原型\n\n1. Promise.prototype.constructor //返回被创建的实例函数. 默认为 Promise 函数.\n2. Promise.prototype.catch //添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的 promise\n3. Promise.prototype.then //添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来 resolve.\n4. Promise.prototype.finally //添加一个事件处理回调于当前 promise 对象，并且在原 promise 对象解析完毕后，返回一个新的 promise 对象。回调会在当前 promise 运行完毕后被调用，无论当前 promise 的状态是完成(fulfilled)还是失败(rejected)\n\n## 使用\n\n```javascript\nconst P=new Promise((resolve,reject)=>{\n    if(/*success*/){\n        resolve()\n    }else{\n        reject()\n    }\n})\n```\n","slug":"apis/Promise"},{"data":{"date":"December 10, 2021","title":"Formatting","tags":["python"],"description":"输出格式化","fromNow":"5 days ago"},"content":"\n当输出数据时，我们希望能够按照一定的格式输出，这个时候就可以使用 format()函数。比如：\n\n```python\n      Name      Shares        Price\n----------  ----------  -----------\n        AA         100        32.20\n       IBM          50        91.10\n       CAT         150        83.44\n      MSFT         200        51.23\n        GE          95        40.37\n      MSFT          50        65.10\n       IBM         100        70.44\n```\n\n## 字符输出格式化\n\n在`python 3.6+`使用`f-strings`格式化字符串，如下：\n\n```python\nname = 'IBM'\nshares = 100\nprice = 91.1\nf'{name:>10s} {shares:>10d} {price:>10.2f}'\n#'       IBM        100      91.10'\n\n# 通常配合 print()函数使用，如下：\nprint(f'{name:>10s} {shares:>10d} {price:>10.2f}')\n```\n\n## 格式化代码\n\n格式代码(在`{}`中`:` 之后)类似于 c `printf ()`。常见代码包括:\n\n```python\nd       # 整数\nb       # 十六进制\nx       # 十六进制\nf       # 浮点数\ne       # 指数\ng       # 指数或浮点数\ns       # 字符串\nc       # 字符\n```\n\n常用的修饰符调整字段宽度和十进制精度。这是一个部分列表:\n\n```python\n:>10d   # 宽度为10，十进制精度无限制\n:<10d   # 宽度为10，十进制精度无限制\n:^10d   # 宽度为10，十进制精度无限制\n:0.2f   # 宽度为无限制，十进制精度为2\n```\n\n## 字典格式化\n\n使用`format_map`函数可以将字典中的键和值对应输出，如下：\n\n```python\ns = {\n    'name': 'IBM',\n    'shares': 100,\n    'price': 91.1\n}\n'{name:>10s} {shares:10d} {price:10.2f}'.format_map(s)\n#'       IBM        100      91.10'\n```\n\n## format()函数\n\n```python\n'{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1)\n#'       IBM        100      91.10'\n'{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1)\n#'       IBM        100      91.10'\n```\n\n## C 语言格式化\n\n使用`%`可以格式化字符串，如下：\n\n```python\n'The value is %d' % 3\n#'The value is 3'\n'%5d %-5d %10d' % (3,4,5)\n#'    3 4              5'\n'%0.2f' % (3.1415926,)\n#'3.14'\n```\n","slug":"python/2.3-formatting"},{"data":{"date":"April 8, 2021","title":"函数、参数、错误","tags":["swift"],"description":"一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。","fromNow":"8 months ago"},"content":"\n## 创建函数\n\nSwift 函数从 func 关键字开始，然后是函数名，然后`{}`。函数的所有主体——都放在大括号内。\n\n```swift\n// 创建函数\nfunc printHelp() {\n    let message = \"\"\"\n\t\tWelcome to MyApp!\n\n\t\tRun this app inside a directory of images and\n\t\tMyApp will resize them all into thumbnails\n\t\t\"\"\"\n    print(message)\n}\n// 调用函数printHelp\nprintHelp()\n```\n\n## 接收参数\n\n函数接收参数，比如内置的`print`函数，参数定义数据类型表示接收的参数类型。\n\n```swift\nprint(\"hello world\") // hello world即为参数\n```\n\n创建函数打印平方值\n\n```swift\nfunc square(number: Int) {\n    print(number * number)\n}\n// Int 表示参数只接受Int类型\nsquare(number: 8) // 64\n```\n\n## 返回值\n\n除了接收数据，函数还可以返回数据。通过`-> <数据类型>`告诉 swift 将返回什么数据类型的值。\n\n```swift\nfunc square(number: Int) -> Int {\n    return number * number\n}\n// -> Int 表示将返回Int类型的值\nlet result = square(number: 8)\nprint(result) // 64\n```\n\n## 参数标签\n\n每一个函数的形式参数都包含形式参数标签和形式参数名两部分\n\n- 形式参数标签用在调用函数的时候\n- 形式参数名用在函数的实现当中\n- 在调用函数的时候，每一个形式参数前边都会有一个形式参数标签\n- 默认情况下，形式参数使用它们的形式参数名作为形式参数标签\n- 如果不想要形式参数标签，可以在形式参数名称前加上`_`\n\n```swift\n//这里的info1和info2就是形式参数标签\n//name和age是形式参数名称\nfunc personalInfo(info1 name : String, info2 age : Int) { //在函数的实现中使用形式参数名称 print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候使用形式参数标签\npersonalInfo(info1: \"norman\", info2: 23)\n\n//下面是默认写法\n//此时，name和age既是形式参数标签，也是形式参数名称\nfunc personalInfo(name : String, age : Int) { //在函数内部实现的时候，name和age是形式参数名称 print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候，name和age是形式参数标签\npersonalInfo(name: \"norman\", age: 24)\n\n//如果不想要形式参数标签，可以在形式参数名称前面加 _\nfunc personalInfo(_ name : String, _ age : Int) { print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候，没有形式参数标签\npersonalInfo(\"norman\", 24)\n```\n\n## 默认参数\n\nswift 允许设置参数默认值，如：\n\n```swift\nfunc greet(_ person: String, nicely: Bool = true) {\n    if nicely == true {\n        print(\"Hello, \\(person)!\")\n    } else {\n        print(\"Oh no, it's \\(person) again...\")\n    }\n}\n\n// 调用\ngreet(\"Taylor\")\ngreet(\"Taylor\", nicely: false)\n```\n\n## 变量参数\n\n当参数不确定，或者参数有多个，在类型后使用`...`，swift 会将传入的值转换为数组，因此可以在函数内部使用循环语句处理。如：\n\n```swift\nfunc square(numbers: Int...) {\n    for number in numbers {\n        print(\"\\(number) squared is \\(number * number)\")\n    }\n}\n\nsquare(numbers: 1, 2, 3, 4, 5)\n```\n\n## io 参数\n\n一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值。\n\n如果想要声明一个变量参数，可以在参数定义前加 inout 关键字，这样就可以改变这个参数的值了。\n\n比如，如果你想将一个数字翻倍——即直接更改值，而不是返回一个新的值——你可以写一个这样的函数：\n\n```swift\nfunc doubleInPlace(number: inout Int) {\n    number *= 2\n}\n\nvar myNum = 10\ndoubleInPlace(number: &myNum)\n```\n\n## 函数总结\n\n- 函数允许我们重复使用代码，而不需要重复声明。\n- 函数可以接受参数——只需告诉 Swift 每个参数的类型。\n- 函数可以返回值，同样，您只需指定要返回的类型。如果您想返回一些内容，可以使用元组。\n- 可以在内部和外部对参数使用不同的名称，也可以完全忽略外部名称。\n- 参数可以具有默认值，这有助于在通常使用特定值时编写更少的代码。\n- 可变参数函数接受零个或多个特定参数，Swift 将输入转换为数组。\n- 函数可以抛出错误，但必须使用 try 和 handle errors 来调用它们。\n- 可以使用 inout 来更改函数内部的变量，但通常最好是返回一个新值。\n","slug":"swift/100days/day05"},{"data":{"date":"October 12, 2020","title":"Linux命令gunzip","tags":["linux"],"description":"“gunzip”命令的快速指南，用于解压缩gzip文件。","fromNow":"a year ago"},"content":"\n“gunzip”命令的快速指南，用于解压缩 gzip 文件。\n\n**gunzip**命令基本上等同于**gzip**命令，但默认情况-d 选项始终处于启用状态。\n\n## 使用方法\n\n```shell\ngunzip filename.gz\n```\n\n这将**gunzip**并删除**.gz**扩展名，将结果放入文件名文件中。如果该文件存在，它将覆盖该文件。\n\n可以使用-c 选项使用输出重定向将其提取到其他文件名：\n\n```shell\ngunzip -c filename.gz > anotherfilename\n```\n\ngunzip 命令可以在 Linux、macOS、WSL 和任何有 UNIX 环境的地方使用\n\n## 参数\n\n- -a 或--ascii 　使用 ASCII 文字模式。\n- -c 或--stdout 或--to-stdout 　把解压后的文件输出到标准输出设备。\n- -f 或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。\n- -h 或--help 　在线帮助。\n- -l 或--list 　列出压缩文件的相关信息。\n- -L 或--license 　显示版本与版权信息。\n- -n 或--no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。\n- -N 或--name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。\n- -q 或--quiet 　不显示警告信息。\n- -r 或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。\n- -S<压缩字尾字符串>或--suffix<压缩字尾字符串> 　更改压缩字尾字符串。\n- -t 或--test 　测试压缩文件是否正确无误。\n- -v 或--verbose 　显示指令执行过程。\n- -V 或--version 显示版本信息。\n","slug":"linux/Linux命令-gunzip"}]},"__N_SSG":true}