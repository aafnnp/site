{"pageProps":{"data":{"date":"December 21, 2020","title":"Docker images","description":"Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器","tags":["docker"],"fromNow":"a year ago"},"content":{"compiledSource":"var u=Object.defineProperty,D=Object.defineProperties;var s=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var c=(e,a,m)=>a in e?u(e,a,{enumerable:!0,configurable:!0,writable:!0,value:m}):e[a]=m,o=(e,a)=>{for(var m in a||(a={}))p.call(a,m)&&c(e,m,a[m]);if(i)for(var m of i(a))r.call(a,m)&&c(e,m,a[m]);return e},t=(e,a)=>D(e,s(a));var n=(e,a)=>{var m={};for(var g in e)p.call(e,g)&&a.indexOf(g)<0&&(m[g]=e[g]);if(e!=null&&i)for(var g of i(e))a.indexOf(g)<0&&r.call(e,g)&&(m[g]=e[g]);return m};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(m){var g=m,{components:e}=g,a=n(g,[\"components\"]);return mdx(MDXLayout,t(o(o({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Docker \\u628A\\u5E94\\u7528\\u7A0B\\u5E8F\\u53CA\\u5176\\u4F9D\\u8D56\\uFF0C\\u6253\\u5305\\u5728 image \\u6587\\u4EF6\\u91CC\\u9762\\u3002\\u53EA\\u6709\\u901A\\u8FC7\\u8FD9\\u4E2A\\u6587\\u4EF6\\uFF0C\\u624D\\u80FD\\u751F\\u6210 Docker \\u5BB9\\u5668\\u3002image \\u6587\\u4EF6\\u53EF\\u4EE5\\u770B\\u4F5C\\u662F\\u5BB9\\u5668\\u7684\\u6A21\\u677F\\u3002Docker \\u6839\\u636E image \\u6587\\u4EF6\\u751F\\u6210\\u5BB9\\u5668\\u7684\\u5B9E\\u4F8B\\u3002\\u540C\\u4E00\\u4E2A image \\u6587\\u4EF6\\uFF0C\\u53EF\\u4EE5\\u751F\\u6210\\u591A\\u4E2A\\u540C\\u65F6\\u8FD0\\u884C\\u7684\\u5BB9\\u5668\\u5B9E\\u4F8B\\u3002\"),mdx(\"p\",null,\"image \\u662F\\u4E8C\\u8FDB\\u5236\\u6587\\u4EF6\\u3002\\u5B9E\\u9645\\u5F00\\u53D1\\u4E2D\\uFF0C\\u4E00\\u4E2A image \\u6587\\u4EF6\\u5F80\\u5F80\\u901A\\u8FC7\\u7EE7\\u627F\\u53E6\\u4E00\\u4E2A image \\u6587\\u4EF6\\uFF0C\\u52A0\\u4E0A\\u4E00\\u4E9B\\u4E2A\\u6027\\u5316\\u8BBE\\u7F6E\\u800C\\u751F\\u6210\\u3002\\u4E3E\\u4F8B\\u6765\\u8BF4\\uFF0C\\u4F60\\u53EF\\u4EE5\\u5728 Ubuntu \\u7684 image \\u57FA\\u7840\\u4E0A\\uFF0C\\u5F80\\u91CC\\u9762\\u52A0\\u5165 Apache \\u670D\\u52A1\\u5668\\uFF0C\\u5F62\\u6210\\u4F60\\u7684 image\\u3002\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-shell\"}),`# \\u5217\\u51FA\\u672C\\u673A\\u7684\\u6240\\u6709 image \\u6587\\u4EF6\\u3002\n$ docker image ls\n\n# \\u5220\\u9664 image \\u6587\\u4EF6\n$ docker image rm [imageName]\n`)),mdx(\"p\",null,\"image \\u6587\\u4EF6\\u662F\\u901A\\u7528\\u7684\\uFF0C\\u4E00\\u53F0\\u673A\\u5668\\u7684 image \\u6587\\u4EF6\\u62F7\\u8D1D\\u5230\\u53E6\\u4E00\\u53F0\\u673A\\u5668\\uFF0C\\u7167\\u6837\\u53EF\\u4EE5\\u4F7F\\u7528\\u3002\\u4E00\\u822C\\u6765\\u8BF4\\uFF0C\\u4E3A\\u4E86\\u8282\\u7701\\u65F6\\u95F4\\uFF0C\\u6211\\u4EEC\\u5E94\\u8BE5\\u5C3D\\u91CF\\u4F7F\\u7528\\u522B\\u4EBA\\u5236\\u4F5C\\u597D\\u7684 image \\u6587\\u4EF6\\uFF0C\\u800C\\u4E0D\\u662F\\u81EA\\u5DF1\\u5236\\u4F5C\\u3002\\u5373\\u4F7F\\u8981\\u5B9A\\u5236\\uFF0C\\u4E5F\\u5E94\\u8BE5\\u57FA\\u4E8E\\u522B\\u4EBA\\u7684 image \\u6587\\u4EF6\\u8FDB\\u884C\\u52A0\\u5DE5\\uFF0C\\u800C\\u4E0D\\u662F\\u4ECE\\u96F6\\u5F00\\u59CB\\u5236\\u4F5C\\u3002\"),mdx(\"p\",null,\"\\u4E3A\\u4E86\\u65B9\\u4FBF\\u5171\\u4EAB\\uFF0Cimage \\u6587\\u4EF6\\u5236\\u4F5C\\u5B8C\\u6210\\u540E\\uFF0C\\u53EF\\u4EE5\\u4E0A\\u4F20\\u5230\\u7F51\\u4E0A\\u7684\\u4ED3\\u5E93\\u3002Docker \\u7684\\u5B98\\u65B9\\u4ED3\\u5E93 Docker Hub \\u662F\\u6700\\u91CD\\u8981\\u3001\\u6700\\u5E38\\u7528\\u7684 image \\u4ED3\\u5E93\\u3002\\u6B64\\u5916\\uFF0C\\u51FA\\u552E\\u81EA\\u5DF1\\u5236\\u4F5C\\u7684 image \\u6587\\u4EF6\\u4E5F\\u662F\\u53EF\\u4EE5\\u7684\\u3002\"),mdx(\"h2\",null,\"\\u66F4\\u591A\"))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"December 21, 2020","title":"Docker images","description":"Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器","tags":["docker"],"fromNow":"a year ago"}},"randomPost":[{"data":{"date":"November 26, 2021","title":"Lists","tags":["python"],"description":"列表（List）是 python 的基本类型","fromNow":"19 days ago"},"content":"\n## 创建列表\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnums = [1, 2, 3]\n```\n\n也可以使用其他方法`split()`创建\n\n```python\nline = 'Hello World!'\nrow = line.split(' ')\nrow # ['Hello', 'World!']\n```\n\n## 列表操作\n\n```python\nnames.append('Adam') # 在末尾添加元素\nnames.insert(1, 'Jack') # 在指定位置添加元素\n```\n\n使用`+`连接两个列表\n\n```python\ns=[1,2,3]\nt=[4,5,6]\ns+t # [1,2,3,4,5,6]\n```\n\n列表索引从 0 开始\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnames[0] # Michael\nnames[1] # Bob\nnames[-1] # Tracy\n```\n\n使用索引覆盖元素\n\n```python\nnames[0] = 'Adam' # 修改第一个元素\nnames # ['Adam', 'Bob', 'Tracy']\n```\n\n使用`len`获取列表长度\n\n```python\nlen(names) # 3\n```\n\n使用`in`判断元素是否在列表中\n\n```python\n'Adam' in names # True\n'manon' in names # False\n```\n\n## 列表的循环\n\n使用`for`循环遍历列表\n\n```python\nfor name in names:\n    print(name)\n```\n\n查找索引值\n\n```python\nnames.index('Bob') # 1\n```\n\n## 移除元素\n\n使用`del`或`remove`删除元素\n\n```python\nnames.remove('Bob') # 删除第一个 Bob\ndel names[0] # 删除第一个元素\n```\n\n## 列表的排序\n\n使用`sort`对列表进行排序\n\n```python\ns = [10, 1, 7, 3]\ns.sort()                    # [1, 3, 7, 10]\n\n# Reverse order\ns = [10, 1, 7, 3]\ns.sort(reverse=True)        # [10, 7, 3, 1]\n\n# It works with any ordered data\ns = ['foo', 'bar', 'spam']\ns.sort()                    # ['bar', 'foo', 'spam']\n```\n\n使用`sorted`创建新的列表，不会修改原列表\n\n```python\nt = sorted(s)\n```\n","slug":"python/1.4-list"},{"data":{"date":"October 30, 2020","title":"Linux命令tar","tags":["linux"],"description":"tar用于linux的文件和目录创建档案，利用tar命令，可以把一大堆的文件和目录全部打包成一个文件","fromNow":"a year ago"},"content":"\n**tar**用于 linux 的文件和目录创建档案，利用 tar 命令，可以把一大堆的文件和目录全部打包成一个文件\n\n## 使用方法\n\n```shell\ntar -cf archive.tar file1 file2\n#c参数代表创建压缩文档，f参数用于写入归档文件。\n\ntar -xf archive.tar\n#x参数代表解压压缩文档\n\ntar -xf archive.tar -C directory\n#C参数代表解压到某个目录\n\ntar -tf archive.tar\n#t参数代表列出压缩文档的内容\n```\n","slug":"linux/Linux命令-tar"},{"data":{"date":"October 19, 2020","title":"css-BFC","tags":["css"],"fromNow":"a year ago"},"content":"\n## 什么是 BFC\n\nBlock Formatting Context（块级格式化上下文）\n\n> Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n\n## 布局规则\n\n- 内部的 Box 会在垂直方向一个接一个地放置\n- Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n- 每个盒子（块盒与行盒）的 margin box 的左边，与包含块 border box 的左边相接触，即使存在浮动也是如此\n- BFC 的区域不会与 float box 重叠\n- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的元素。反之也是如此\n- 计算 BFC 的高度时，浮动元素也参与计算\n\n## 如何创建 BFC\n\n- 根元素或其他包含他的元素\n- 浮动元素（元素的 float 不是 none）\n- 绝对定位元素（元素具有 position 为 absolute 或 fixed）\n- 内联块（元素具有 display: inline-block）\n- 表格单元格（元素具有 display: table-cell ，HTML 表格单元格默认属性）\n- 表格标题（元素具有 display: table-caption，HTML 表格标题默认属性）\n- 具有 overflow 且值不是 visible 的块元素\n- 弹性盒子（flex 或 inline-flex）\n- ` css display: flow-root`\n- `css column-span: all`\n\n## BFC 作用\n\n- 利用 BFC 避免 margin 重叠\n- 自适应两栏布局\n- 清除浮动\n","slug":"interview/css/BFC"},{"data":{"date":"March 11, 2019","title":"Promise","tags":["javascript"],"fromNow":"3 years ago"},"content":"\n## Promise\n\n> 用于一个异步操作的最终完成或失败及其结果\n\n## 状态\n\n1. pending，初识状态\n2. fulfilled，操作成功\n3. rejected，操作失败\n\n## 流程\n\n![](https://cdn.jsdelivr.net/gh/funnypan/pics@master/img/20190830101852.png)\n\n## 语法\n\n```javascript\nnew Promise((resolve, reject) => {\n  /*executor*/\n});\n```\n\n> Promise 执行时立即调用 executor 函数（通常是一些异步操作），resovle 将 Promise 的状态改为 fulfilled，reject 将 Promise 的状态改为 rejected，如果 catch 到了错误，将忽略 executor 内的返回值，Promise 的状态被改成 rejected\n\n## 属性\n\n1. Promise.length //1\n2. Promise.prototype //Promise 的构造器的原型\n\n## 方法\n\n1. Promise.all //Promise.all 方法常被用于处理多个 promise 对象的状态集合\n2. Promise.race //当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。\n3. Promise.reject //返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法\n4. Promise.resolve //返回的 Promise 对象状态为 fulfilled\n\n## 原型\n\n1. Promise.prototype.constructor //返回被创建的实例函数. 默认为 Promise 函数.\n2. Promise.prototype.catch //添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的 promise\n3. Promise.prototype.then //添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来 resolve.\n4. Promise.prototype.finally //添加一个事件处理回调于当前 promise 对象，并且在原 promise 对象解析完毕后，返回一个新的 promise 对象。回调会在当前 promise 运行完毕后被调用，无论当前 promise 的状态是完成(fulfilled)还是失败(rejected)\n\n## 使用\n\n```javascript\nconst P=new Promise((resolve,reject)=>{\n    if(/*success*/){\n        resolve()\n    }else{\n        reject()\n    }\n})\n```\n","slug":"apis/Promise"},{"data":{"date":"May 19, 2020","title":"this的指向","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n![](https://cdn.jsdelivr.net/gh/funnypan/pics@master/img/20200413141906.png)\n\n## this 指向\n\nthis 总是指向函数的直接调⽤者（⽽⾮间接调⽤者）\n\n如果有 new 关键字， this 指向 new 出来的那个对象\n\n在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的 this 总是指向全局对象 Window\n\n> 创建⼀个空对象，并且 this 变量引⽤该对象，同时还继承了该函数的原型属性和⽅法被加⼊到 this 引⽤的对象中新创建的对象由 this 所引⽤，并且最后隐式的返回 this\n\n```javascript\nvar test = {\n  prop: 42,\n  func: function () {\n    return this.prop;\n  },\n};\n\nconsole.log(test.func()); //42，调用者是test\n//42\n\nvar fullname = 'David Jones';\nvar obj = {\n  fullname: 'Colin Brown',\n  prop: {\n    fullname: 'Aurelio Deftch',\n    getFullname: function () {\n      return this.fullname;\n    },\n  },\n};\nvar test = obj.prop.getFullname;\nconsole.log(test()); // David Jones，调用者是window，window.fullname是David Jones\nobj.prop.getFullname(); // Aurelio Deftch，调用者是obj.prop，obj.prop.fullname是Aurelio Deftch\n```\n\n## 扩展（call、bind、apply）\n\n- apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；\n- apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；\n- apply 、 call 、bind 三者都可以利用后续参数传参；\n- bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。\n\n### apply、call\n\n- apply、call 是为了改变某个函数运行时的上下文（context）而存在的，即改变函数体内部的 this 指向\n- 作用一样，区别在于接受的参数不一样\n- func.call(this,args)\n- func.apply(this,[args])\n- 用法：当知道参数数量的时候用 call，不确定的时候用 apply\n\n```javascript\nfunction log() {\n  var _args = [...arguments];\n  console.log(_args);\n  args.unshift('(app)');\n\n  console.log.apply(console, args);\n}\nlog(1, 2, 3); //(app) 1 2 3\n```\n\n### bind\n\n> MDN 的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n```javascript\nvar bar = function () {\n  console.log(this.x);\n};\nvar foo = {\n  x: 3,\n};\nbar(); // undefined\nvar func = bar.bind(foo);\nfunc(); // 3,this指向了foo\n```\n","slug":"javascript/advance/this指向"},{"data":{"date":"October 19, 2019","title":"安装mongodb","tags":["server"],"fromNow":"2 years ago"},"content":"\n## 安装 mongodb\n\n## 添加 mongodb 源\n\n```bash\nsudo vi /etc/yum.repos.d/mongodb-org.repo\n\n\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n```bash\nyum repolist\n```\n\n## 安装 mongodb\n\n```bash\nsudo yum install mongodb-org\n\n启动\nsudo systemctl start mongod\n\n重载\nsudo systemctl reload mongod\n\n停止\nsudo systemctl stop mongod\n\n重启\nsudo systemctl restart mongod\n\n加入自启\nsudo systemctl enable mongod\n\n检查状态\nsystemctl status mongod\n\n```\n","slug":"server/安装mongodb"}]},"__N_SSG":true}