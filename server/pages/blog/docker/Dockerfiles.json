{"pageProps":{"data":{"date":"January 8, 2021","title":"Dockerfile","description":"Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明","tags":["docker"],"fromNow":"a year ago"},"content":{"compiledSource":"var m=Object.defineProperty,d=Object.defineProperties;var D=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var t=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var n=(e,a,o)=>a in e?m(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,l=(e,a)=>{for(var o in a||(a={}))t.call(a,o)&&n(e,o,a[o]);if(p)for(var o of p(a))c.call(a,o)&&n(e,o,a[o]);return e},i=(e,a)=>d(e,D(a));var s=(e,a)=>{var o={};for(var r in e)t.call(e,r)&&a.indexOf(r)<0&&(o[r]=e[r]);if(e!=null&&p)for(var r of p(e))a.indexOf(r)<0&&c.call(e,r)&&(o[r]=e[r]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var r=o,{components:e}=r,a=s(r,[\"components\"]);return mdx(MDXLayout,i(l(l({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"Dockerfile \\u662F\\u4E00\\u4E2A\\u5305\\u542B\\u7528\\u4E8E\\u7EC4\\u5408\\u6620\\u50CF\\u7684\\u547D\\u4EE4\\u7684\\u6587\\u672C\\u6587\\u6863\\u3002\\u53EF\\u4EE5\\u4F7F\\u7528\\u5728\\u547D\\u4EE4\\u884C\\u4E2D\\u8C03\\u7528\\u4EFB\\u4F55\\u547D\\u4EE4\\u3002 Docker \\u901A\\u8FC7\\u8BFB\\u53D6 Dockerfile \\u4E2D\\u7684\\u6307\\u4EE4\\u81EA\\u52A8\\u751F\\u6210\\u6620\\u50CF\\u3002 docker build \\u547D\\u4EE4\\u7528\\u4E8E\\u4ECE Dockerfile \\u6784\\u5EFA\\u6620\\u50CF\\u3002\\u53EF\\u4EE5\\u5728 docker build \\u547D\\u4EE4\\u4E2D\\u4F7F\\u7528-f \\u6807\\u5FD7\\u6307\\u5411\\u6587\\u4EF6\\u7CFB\\u7EDF\\u4E2D\\u4EFB\\u4F55\\u4F4D\\u7F6E\\u7684 Dockerfile\\u3002\")),mdx(\"h2\",null,\"\\u6587\\u4EF6\\u8BF4\\u660E\"),mdx(\"p\",null,\"Docker \\u4ECE\\u4E0A\\u5230\\u4E0B\\u7684\\u987A\\u5E8F\\u8FD0\\u884C Dockerfile \\u7684\\u6307\\u4EE4\\uFF0C\\u7B2C\\u4E00\\u6761\\u6307\\u4EE4\\u5FC5\\u987B\\u662F FROM\\u3002\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"FROM\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u8BBE\\u7F6E\\u57FA\\u672C\\u6620\\u50CF\\uFF0CFROM \\u5FC5\\u987B\\u4F5C\\u4E3A\\u7B2C\\u4E00\\u6761\\u6307\\u4EE4\"),mdx(\"ol\",l({},{start:2}),mdx(\"li\",{parentName:\"ol\"},\"LABEL\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u6DFB\\u52A0\\u6807\\u7B7E\\uFF0C\\u8BBE\\u7F6E\\u6620\\u50CF\\u6807\\u7B7E\"),mdx(\"pre\",null,mdx(\"code\",l({parentName:\"pre\"},{className:\"language-dockerfile\"}),`LABEL maintainer=\"manon.icu\"\n`)),mdx(\"ol\",l({},{start:3}),mdx(\"li\",{parentName:\"ol\"},\"RUN\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u6267\\u884C\\u5F53\\u524D\\u6620\\u50CF\\u7684\\u4EFB\\u4F55\\u547D\\u4EE4\"),mdx(\"pre\",null,mdx(\"code\",l({parentName:\"pre\"},{className:\"language-dockerfile\"}),`RUN /bin/bash -c \"source $HOME/.bashrc;echo $HOME\"\n`)),mdx(\"ol\",l({},{start:4}),mdx(\"li\",{parentName:\"ol\"},\"CMD\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u6267\\u884C\\u6620\\u50CF\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\"),mdx(\"pre\",null,mdx(\"code\",l({parentName:\"pre\"},{className:\"language-dockerfile\"}),`CMD [\"executable\",\"param1\",\"param2\"]\n`)),mdx(\"ol\",l({},{start:5}),mdx(\"li\",{parentName:\"ol\"},\"COPY/ADD\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u5C06\\u6E90\\u6587\\u4EF6\\u590D\\u5236\\u5230\\u76EE\\u7684\\u5730\"),mdx(\"pre\",null,mdx(\"code\",l({parentName:\"pre\"},{className:\"language-dockerfile\"}),`COPY dist /www/dist\n`)),mdx(\"ol\",l({},{start:6}),mdx(\"li\",{parentName:\"ol\"},\"WORKDIR\")),mdx(\"p\",null,\"\\u7528\\u4E8E\\u4E3A RUN/CMD/COPY \\u6307\\u4EE4\\u8BBE\\u7F6E\\u5DE5\\u4F5C\\u76EE\\u5F55\\uFF0C\\u5982\\u4E0D\\u5B58\\u5728\\uFF0C\\u4F1A\\u9ED8\\u8BA4\\u521B\\u5EFA\"),mdx(\"h2\",null,\"\\u5B8C\\u6574\\u7684 Dockerfile\"),mdx(\"pre\",null,mdx(\"code\",l({parentName:\"pre\"},{className:\"language-dockerfile\"}),`FROM node:lts-alpine\n\nWORKDIR /app\nADD . /app\nRUN npm install\n\nCMD [\"npm\", \"start\"]\n`)),mdx(\"h2\",null,\"\\u66F4\\u591A\"))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"January 8, 2021","title":"Dockerfile","description":"Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明","tags":["docker"],"fromNow":"a year ago"}},"randomPost":[{"data":{"date":"May 19, 2020","title":"类型判断","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## typeof\n\n> 用于判断操作数的数据类型，适用于除 null、object 的其他 5 种类型的判断。\n\n1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n2. 对于引用类型，除 function 以外，一律返回 object 类型。\n3. 对于 null ，返回 object 类型。\n4. 对于 function 返回 function 类型。\n\n```javascript\ntypeof undefined; // \"undefined\";\ntypeof 1; // \"number\";\ntypeof '1'; // \"string\";\ntypeof true; // \"boolean\";\ntypeof Symbol(); // \"symbol\";\ntypeof { a: 1 }; // \"object\";\n\ntypeof null === 'object'; // true\ntypeof function () {} === 'function'; // true\n```\n\n## instanceof\n\n> 用于判断是对象的那个子类型\n\n```javascript\n[1, 2] instanceof Array; // true\n(function foo() {} instanceof Function); // true\nnew Date(2018) instanceof Date; // true\nnew Number(1) instanceof Number; // true\n1 instanceof Number; // false\n```\n\na instanceof b，instanceof 会去查找 a 的原型链(这里不展开讨论)上是否有 b 的 prototype 属性；如果有，就返回 true，否则返回 false。即判断 a 的原型链上是否有 a.\\_proto\\_\\_ === b.prototype 返回 true\n\n## constructor\n\n> 不仅可以用于对象子类型的判断，还可以用于基本类型的判断，返回创建实例对象的 Object 构造函数的引用，原始数据类型，constructor 只读，基本类型指向对应的内置对象的构造函数\n\n```javascript\n({ a: 1 }.constructor === Object); // true\n[1, 2].constructor === Array; // true\nnew Date(2018).constructor === Date; // true\n(function foo() {}.constructor === Function); // true\n'1'.constructor === String; // true\n(1).constructor === Number; // true\ntrue.constructor === Boolean; // true\n```\n\n## prototype\n\n> Object.prototype.toString.call('...')，通用方法判断对象类型。 Object.prototype 表示 Object 的原型对象，toString 返回表示该对象的字符串，call 用于指定 this\n\n```javascript\nObject.prototype.toString.call('1'); // \"[object String]\"\nObject.prototype.toString.call(1); // \"[object Number]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call([1, 2, 3]); // \"[object Array]\"\nObject.prototype.toString.call(function foo() {}); // \"[object Function]\"\nObject.prototype.toString.call(null); //\"[object Null]\"\nObject.prototype.toString.call(undefined); //\"[object Undefined]\"\n```\n","slug":"javascript/advance/类型判断"},{"data":{"date":"January 19, 2020","title":"使用js获取位置","tags":["i18n","javascript"],"fromNow":"2 years ago"},"content":"\n![quick-tip-detecting-your-location-with-javascript](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20190121163457.png)\n\n首先，我们使用 caniuse-cmd 查看下 geolocation 的兼容性,几乎所有的现代浏览器都支持 geolocation\n\nGeolocation 通过使用 GPS、WIFI、IP 地址检测自己的位置信息，开发人员可使用这些信息给用户提供更好的搜索建议，比如附近的便利店，并实现互动。\n\n本地资源（location sources） JavaScript 提供了一个简单，但功能强大的工具来定位设备的地理定位 API 的形式。它包括一个小的一组易于使用的方法，可以获得设备的位置：\n\nGPS-主要在移动设备，精确到 10 米 WIFI-几乎所有的联网设备 IP-仅限于区域，备选方案采用哪种方案取决于浏览器支持，一般情况下 WIFI 快于 GPS 快于 IP\n\n使用 geolocation api 通过使用 caniuse-cmd，我们知道大部分浏览器支持 geolocation，但我们需要做好判断，请确保可以正常使用 geolocation\n\n```javascript\nif (navigator.geolocation) {\n  // 支持geolocation\n} else {\n  // 不支持geolocation\n}\n```\n\nnavigator.geolocation 有如下几个方法：\n\n- Geolocation.getCurrentPosition() //获取当前位置\n- Geolocation.watchPosition() //监测定位\n- Geolocation.clearWatch() //清除监测\n\ngetCurrentPosition() and watchPosition() methods 的工作方式是基本相同的。这两方法目的基本相同，都是用来去获取 device 的位置信息吧， 都是以一个异步的工作形式来获取位置信息的， 他们也都依赖于一个 attempt call 的结果\n\n```javascript\nnavigator.geolocation.getCurrentPosition(\n\n    // 位置获取成功\n    function(position) {\n\n        position = {\n            coords: {\n                latitude - //纬度.\n                longitude - //经度.\n                altitude - //高度.\n                accuracy - //精确度.\n                altitudeAccuracy - //高度的准确性.\n                heading - //.\n                speed - //.\n            }\n            timestamp - //时间戳.\n        }\n\n    },\n\n    // 位置获取失败\n    function(error){\n\n    }\n);\n```\n\n如上，使用 geolocation api 很简单，只需要正确调用方法，等待返回坐标即可。\n\n用户权限由于 geolocation api 会暴露用户信息，所以当应用程序访问的时候，将以弹窗请求用户操作，如下\n\n主机安全另一个保护措施是使用 HTTPS 连接。由于一个新的网络安全策略，谷歌浏览器（桌面版和手机版）不再允许非安全的主机上运行的 geolocation api。使用 https 可以最大限度的减少数据信息的盗用或被滥用的风险。\n\n这里查看更多关于这个问题。\n\n```javascript\n一个简单的Demo;\nfindMeButton.on('click', function () {\n  navigator.geolocation.getCurrentPosition(function (position) {\n    // Get the coordinates of the current position.\n    var lat = position.coords.latitude;\n    var lng = position.coords.longitude;\n\n    // Create a new map and place a marker at the device location.\n    var map = new GMaps({\n      el: '#map',\n      lat: lat,\n      lng: lng,\n    });\n\n    map.addMarker({\n      lat: lat,\n      lng: lng,\n    });\n  });\n});\n```\n\n[在线 demo](https://jsfiddle.net/dannymarkov/ubrvm4ao/ 'https://jsfiddle.net/dannymarkov/ubrvm4ao/')\n\n翻译自[Detecting Your Location With JavaScript](http://tutorialzine.com/2016/06/quick-tip-detecting-your-location-with-javascript/ 'http://tutorialzine.com/2016/06/quick-tip-detecting-your-location-with-javascript/')\n","slug":"translate/使用js获取位置"},{"data":{"date":"April 12, 2018","title":"Flexbox指南","tags":["css"],"description":"Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。","fromNow":"4 years ago"},"content":"\n![Flexbox](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181016105026.png)\n\nFlexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。\n\n- 基本介绍\n- 浏览器兼容性\n- 启用 Flexbox\n- 容器属性\n  - 行||列 对齐 ==row and columns==\n  - 水平||垂直 对齐 ==Vertical and horizontal==\n  - 更改水平对齐 ==change horizontal alignment==\n  - 更改垂直对齐 ==change vertical alignment==\n    - 关于基准线 ==about baseline==\n  - 换行 ==wrap==\n- flex 元素上的属性\n  - order\n  - align-self\n  - flex-grow\n  - flex-shrink\n  - flex-basis\n  - flex\n\n### 介绍\n\nFlexbox，也称为灵活盒模块，是两个现代布局系统之一，还有 CSS Grid。与 CSS Grid（二维）相比，flexbox 是一维布局模型。它将基于行或列控制布局，但不能同时控制布局。flexbox 的主要目标是允许项目填充其容器提供的整个空间，具体取决于您设置的一些规则。Flexbox 不兼容 IE10 以下，IE10 以下可以使用如下方式：\n\n- Table layouts\n- Floats\n- clearfix hacks\n- display: table hacks\n\n### 兼容性\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205051.png)\n\nIE10 以下不兼容，一些浏览器需要使用-webkit 或者 display:-webkit-box 兼容处理。\n\n### 使用 flexbox\n\n```css\ndisplay: flexbox;\n```\n\n或者\n\n```css\ndisplay: inline-flexbox;\n```\n\n### 容器属性\n\n- flex-direction\n- justify-content\n- align-items\n- flex-wrap\n- flex-flow\n\n### 行对齐或者列对齐\n\nflex-direction 决定容器以行对齐还是列对齐。\n\n- flex-direction:row，行对齐，从左到右\n- flex-direction:row-reverse，行对齐，从右到左\n- flex-direction:column，列对齐，从上到下\n- flex-direction:column-reverse，列对齐，从下到上\n\n如下图所示：\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205713.png)\n\n### 水平对齐或者垂直对齐\n\nflex-direction 默认是 row，从左向右，当其属性值为 column 时，是从上到下，可以使用 justify-content 和 align-items 改变水平和垂直对齐。\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100130.png)\n\n### 改变水平对齐方式\n\njustify-content 有 5 个属性值：\n\n1. flex-start 左对齐\n2. flex-end 右对齐\n3. center 居中对齐\n4. space-between 首尾对齐容器左右侧，中间间距相等\n5. space-around 每个元素的间距相等\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100921.png)\n\n### 改变垂直对齐方式\n\nalign-items 有 5 个属性值：\n\n1. flex-start 顶部对齐\n2. flex-end 底部对齐\n3. center 居中对齐\n4. baseline 基线对齐\n5. stretch 拉伸以适应容器\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022141409.png)\n\n关于 align-items:baseline，可以看看 codepen：[https://codepen.io/flaviocopes/pen/oExoJR](https://codepen.io/flaviocopes/pen/oExoJR)\n\n### 换行\n\n默认情况下，flexbox 容器中的项目保留在一行中，缩小它们以适合容器。\n\n可以使用 flex-wrap:wrap 或者 flex-wrap:wrap-reverse 对容器中的元素进行换行处理。\n\n一种简写方式：flex-flow:row wrap;即 flex-direction:row && flex-wrap:wrap\n\n### 适用于 flexbox 容器内每个元素的属性\n\n1. order\n2. align-self\n3. flex-grow\n4. flex-shrink\n5. flex-basis\n6. flex\n\n#### order-改变元素的顺序，如下图所示，可以指定某个元素的 order 值，以改变其位置，默认值为 0\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142507.png)\n\n#### align-self-元素使用 align-self 覆盖容器的 align-items 对当前元素的对齐方式\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142842.png)\n\n#### flex-grow || flex-shrink 如有必要，可以增加或缩小某个元素\n\nflex-grow：默认值为 0，当某个元素 flex-grow 为 1，另一个为 2，则为 flex-grow：2 的元素占用 flex-grow:1 的空间的 2 倍。\n\nflex-shrink：默认值为 1，如果没有显示定义该属性，将会自动按照默认值 1 在所有因子相加之后计算比率来进行空间收缩。\n\n比如：有这么一个容器，div>.box1*3+.box2*2 父容器定义宽度为 500px，子元素定义宽度为 120px，box1 的 flex-shrink 为 1，.box2 的 flex-shrink 为 2，那么子项相加之后即为 600 px，超出父容器 100px。那么超出的 100px 需要被 A、B、C、D、E 消化 通过收缩因子，所以加权综合可得 100*1+100*1+100*1+100*2+100\\*2=700px。\n\n```\n于是我们可以计算 A、B、C、D、E 将被移除的溢出量是多少：\nA 被移除溢出量：(100*1/700)*100，即约等于14px\nB 被移除溢出量：(100*1/700)*100，即约等于14px\nC 被移除溢出量：(100*1/700)*100，即约等于14px\nD 被移除溢出量：(100*2/700)*100，即约等于28px\nE 被移除溢出量：(100*2/700)*100，即约等于28px\n\n最后A、B、C、D、E的实际宽度分别为：120-14=106px, 120-14=106px, 120-14=106px, 120-28=92px,120-28=92px\n```\n\n#### flex-basis-用于设置或检索弹性盒伸缩基准值，默认值为 auto，其与 width 的区别可以参考这篇文章：https://www.jianshu.com/p/17b1b445ecd4\n\n#### flex：有三个属性值\n\n1. flex-grow\n2. flex-shrink\n3. flex-basis\n\n```css\nflex: 0 1 auto 分别对应flex-grow、flex-shrink、flex-basis;\n```\n\n## 结尾\n\n友情献上小游戏，通过游戏学习 flexbox\n\nhttp://flexboxfroggy.com/#zh-cn\n","slug":"css/Flexbox指南"},{"data":{"date":"May 19, 2020","title":"原型和原型链","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n![Dyv0vb](https://cdn.jsdelivr.net/gh/funnyPan/pics@master/uPic/Dyv0vb.jpg)\n\n每个对象都会在其内部初始化⼀个属性，就是`prototype`(原型)，当我们访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去`prototype` ⾥找这个属性，这个`prototype`⼜会有⾃⼰的`prototype`，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念关系：`instance.constructor.prototype = instance.__proto__` 特点： JavaScript 对象是通过引⽤来传递的，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的`Prototype`对象是否有这个属性，如此递推下去，⼀直检索到`Object`内建对象\n\n## 原型：\n\nJavaScript 的所有对象中都包含了⼀个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型\n\nJavaScript 的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型[__proto__] 。\n\n## 原型链：\n\n当⼀个对象调⽤的属性/⽅法⾃身不存在时，就会去⾃⼰ [__proto__] 关联的前辈 prototype 对象上去找如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/⽅法或 undefined 为⽌。从⽽形成了所谓的“原型链”\n\n## 原型特点：\n\nJavaScript 对象是通过引⽤来传递的，当修改原型时，与之相关的对象也会继承这⼀改变\n","slug":"javascript/advance/原型和原型链"},{"data":{"date":"July 12, 2017","title":"三角形绘制方法","tags":["css"],"description":"在做UI（页面重构）的时候，免不了和各种小图标打交道，这其中最多的应该是三角形以及箭头","fromNow":"4 years ago"},"content":"\n在做 UI（页面重构）的时候，免不了和各种小图标打交道，这其中最多的应该是三角形以及箭头，一般情况下可以通过伪类使用 unicode 解决大部分问题。\n\n现在我们来总结下几种使用 css 绘制三角形的方法，dom 结构如下：\n\n```html\n<div class=\"triangle\"></div>\n```\n\n## 最简单最方便的办法 background\n\n```\n代码忽略\n```\n\n## unicode\n\n```css\n.triangle:after {\n  display: block;\n  content: '\\25B2';\n  color: '#fd5353';\n  font-size: 20px;\n}\n```\n\n> 注意，伪类必须加上 content 属性，否则不生效\n\n[unicode 图表](http://www.w3cplus.com/solution/css3content/images/html.png)\n\n## border\n\n```css\n.triangle {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n}\n```\n\n使用 border 绘制三角形是什么原理？事实上，宽度相等的 border 是以 45 度对接的，如下图：\n\n![image](https://i.stack.imgur.com/hZefy.png)\n\n那么没有了上 border 就是如下图：\n\n![image](https://i.stack.imgur.com/uV9Q5.png)\n\n再设置 div 的宽度为 0，就是如下图：\n\n![image](https://i.stack.imgur.com/K1A7G.png)\n\n再设置 div 的高度为 0，如下图：\n\n![image](https://i.stack.imgur.com/NsmsW.png)\n\n最后设置左右 border 的颜色为透明，如下图：\n\n![image](https://i.stack.imgur.com/B42zY.png)\n\n再来个动图：\n\n![image](https://i.stack.imgur.com/vYvqa.gif)\n\n通过这种原理，我们可以做更多的图形，比如五角星、六角星等，更多图形请移步[shapesofcss](https://css-tricks.com/examples/ShapesOfCSS/)\n\n## 使用 css3 transform rotate\n\n![image](https://i.stack.imgur.com/mEaS1.jpg)\n\n```css\n.triangle {\n  width: 30%;\n  padding-bottom: 21.27%; /* = width / 1.41 */\n  position: relative;\n\n  //划重点\n  overflow: hidden;\n}\n\n.triangle: before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: #0079c6;\n\n  //划重点\n  transform-origin: 0 100%;\n  transform: rotate(45deg);\n}\n```\n\n> 为什么是 1.41，因为正方形的对角线长度是约等于 1.414。\n\n## 使用 clip-path\n\n```css\n.triangle {\n  width: 200px;\n  height: 200px;\n  background: #fd5353;\n  clip-path: polygon(50% 0, 0 100%, 100% 100%);\n}\n```\n\nclip-path 不支持安卓 4.4 以下，其余均需使用浏览器前缀-webkit，[caniuse](http://caniuse.com/#feat=css-clip-path)\n\n详细请移步 [clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)\n","slug":"css/css三角形绘制方法总结"},{"data":{"date":"May 21, 2020","title":"Go-HelloWorld","tags":["go"],"fromNow":"2 years ago"},"content":"\n## 搭建开发环境\n\n让我们创建一个目录，在该目录中编写我们的 hello world 程序。打开终端并运行以下命令。\n\n```shell\nmkdir ~/Documents/learngo/\n```\n\n上面的命令将 learngo 在当前用户的 Documents 目录中创建一个名为目录。\n\n### 你好，世界\n\n使用您喜欢的文本编辑器 main.go 在 learngo 目录中创建一个名为以下内容的文件。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello World\")\n}\n```\n\n按照 Go 中的约定，将包含 main 函数的文件命名为 main.go。\n\n### 运行程序\n\n1. go install\n\n```shell\ncd ~/Documents/learngo/\ngo install\n#此命令将编译程序并将编译好的二进制文件复制到~/go/bin内\nls -al ~/go/bin/\n\n~/go/bin/learngo\n#输出hello world\n```\n\n2. go build\n\n```shell\ncd ~/Documents/learngo/\ngo build\n#上面的命令将learngo在当前目录中创建一个二进制文件。ls -al将显示learngo已创建一个名为的文件。\n./learngo\n#输出Hello World\n```\n\n3. go run\n\ncd ~/Documents/learngo/在终端中键入命令以将当前目录更改为 learngo。\n\n```shell\ngo run main.go\nHello World\n#go run和go build/go install命令之间的细微差别是，go run需要.go文件名作为参数。\n```\n\ngo run 工作原理非常相似 go build。无需将程序编译并安装到当前目录，而是将文件编译到一个临时位置并从该位置运行文件。如果您想知道 go run 将文件编译到的位置，请 go run 使用--work 参数运行。\n\n```shell\ngo run --work main.go\n```\n\n4. go playground\n\n<Gist gistLink=\"Manonicu/ef552d29300ffb0cd311d9cc8828bc6e\" />\n\n我们将简要讨论该程序的每一行的作用。\n\n- package main - 每个 go 文件必须以 package name 开始。\n- import \"fmt\" - import 语句用于导入其他软件\n\n  包\n\n- func main（）- func 关键字标记函数的开始。\n- fmt.Println（\"H​​ello World\"）\n","slug":"go/第一个Go程序"}]},"__N_SSG":true}