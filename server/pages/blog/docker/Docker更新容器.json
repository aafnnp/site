{"pageProps":{"data":{"date":"January 11, 2021","title":"Docker更新容器","tags":["docker"],"fromNow":"a year ago"},"content":{"compiledSource":"var g=Object.defineProperty,u=Object.defineProperties;var i=Object.getOwnPropertyDescriptors;var m=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,t=Object.prototype.propertyIsEnumerable;var c=(e,a,o)=>a in e?g(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,p=(e,a)=>{for(var o in a||(a={}))r.call(a,o)&&c(e,o,a[o]);if(m)for(var o of m(a))t.call(a,o)&&c(e,o,a[o]);return e},s=(e,a)=>u(e,i(a));var d=(e,a)=>{var o={};for(var n in e)r.call(e,n)&&a.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&m)for(var n of m(e))a.indexOf(n)<0&&t.call(e,n)&&(o[n]=e[n]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var n=o,{components:e}=n,a=d(n,[\"components\"]);return mdx(MDXLayout,s(p(p({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"\\u5F53\\u4F60\\u90E8\\u7F72\\u4F60\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\\uFF0C\\u7136\\u540E\\u4F60\\u60F3\\u4FEE\\u590D\\u4E00\\u4E2A bug\\uFF0C\\u6216\\u8005\\u53EA\\u662F\\u53D1\\u5E03\\u4E00\\u4E2A\\u66F4\\u65B0\\uFF0C\\u4F1A\\u53D1\\u751F\\u4EC0\\u4E48\\uFF1F\"),mdx(\"p\",null,\"\\u8FD0\\u884C\\u5BB9\\u5668\\u540E\\uFF0C\\u53EF\\u4EE5\\u4F7F\\u7528 docker ps \\u83B7\\u53D6\\u5176 ID\\uFF0C\\u7136\\u540E\\u4F7F\\u7528 docker commit \\u4ECE\\u4E2D\\u4E3A\\u56FE\\u50CF\\u521B\\u5EFA\\u65B0\\u6807\\u8BB0\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",p({parentName:\"pre\"},{className:\"language-shell\"}),`docker commit <id> <username>/<imagename>:<tagname>\n`)),mdx(\"p\",null,\"\\u60A8\\u8FD8\\u53EF\\u4EE5\\u6DFB\\u52A0\\u4E00\\u6761 changelog \\u6D88\\u606F\\uFF0C\\u5217\\u51FA\\u65B0\\u7248\\u672C\\u4E2D\\u66F4\\u6539\\u7684\\u5185\\u5BB9\\uFF1A\"),mdx(\"pre\",null,mdx(\"code\",p({parentName:\"pre\"},{className:\"language-shell\"}),`docker commit --change \"description\" <id> <username>/<imagename>:<tagname>\n`)),mdx(\"h2\",null,\"\\u66F4\\u591A\"))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"January 11, 2021","title":"Docker更新容器","tags":["docker"],"fromNow":"a year ago"}},"randomPost":[{"data":{"date":"October 10, 2020","title":"Linux命令xargs","tags":["linux"],"description":"xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具","fromNow":"a year ago"},"content":"\nxargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\n\n## 使用方法\n\n```shell\ncommand1 | xargs command2\n```\n\n我们使用**|**将输出传递给 xargs。这将负责运行 command2 命令，使用 command1 的输出作为其参数。\n\n## 例子\n\n让我们举一个简单的例子。您要从目录中删除某些特定文件。这些文件列在文本文件中。我们有 3 个文件：file1，file2，file3。在**todelete.txt**我们有一个要删除的文件列表，在本例中为 file1 和 file3：\n\n```shell\ncat todelete.txt\n\nfile1\nfile2\n```\n\n![nXyQfk](https://cdn.jsdelivr.net/gh/funnyPan/pics@master/uPic/nXyQfk.png)\n\n通过 cat 命令将 todelete 内容输出并执行 rm 命令\n\n```shell\ncat todelete.txt | xargs rm\n```\n\n## 参数\n\n- -a file 从文件中读入作为 sdtin\n- -e flag ，注意有的时候可能会是-E，flag 必须是一个以空格分隔的标志，当 xargs 分析到含有 flag 这个标志的时候就停止。\n- -p 当每次执行一个 argument 的时候询问一次用户。\n- -n num 后面加次数，表示命令在执行的时候一次用的 argument 的个数，默认是用所有的。\n- -t 表示先打印命令，然后再执行。\n- -i 或者是-I，这得看 linux 支持了，将 xargs 的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。\n- -r no-run-if-empty 当 xargs 的输入为空的时候则停止 xargs，不用再去执行了。\n- -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。\n- -L num 从标准输入一次读取 num 行送给 command 命令。\n- -l 同 -L。\n- -d delim 分隔符，默认的 xargs 分隔符是回车，argument 的分隔符是空格，这里修改的是 xargs 的分隔符。\n- -x exit 的意思，主要是配合-s 使用。。\n- -P 修改最大的进程数，默认是 1，为 0 时候为 as many as it can ，这个例子我没有想到，应该平时都用不到的吧。\n","slug":"linux/Linux命令-xargs"},{"data":{"date":"May 12, 2018","title":"Object","tags":["javascript"],"fromNow":"4 years ago"},"content":"\n## Object\n\n> 任何非原始类型的值（字符串，数字，布尔值，符号，null 或未定义）都是对象，数组和函数也不例外。\n\n## 内置属性\n\n1. Object.length=1\n2. Object.prototype\n\n## 静态方法\n\n1. Object.assign() **_ES2015_** //通过复制一个或多个对象来创建一个新的对象。\n2. Object.create() //使用指定的原型对象和属性创建一个新对象。\n3. Object.defineProperty() //给对象添加一个属性并指定该属性的配置。\n4. Object.defineProperties() //给对象添加多个属性并分别指定它们的配置。\n5. Object.entries() **_ES2017_** //返回给定对象自身可枚举属性的 [key, value] 数组。\n6. Object.freeze() //冻结对象：其他代码不能删除或更改任何属性。\n7. Object.getOwnPropertyDescriptor() //返回对象指定的属性配置。\n8. Object.getOwnPropertyNames() //返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。\n9. Object.getOwnPropertySymbols() //返回一个数组，它包含了指定对象自身所有的符号属性。\n10. Object.getPrototypeOf() //返回指定对象的原型对象。\n11. Object.is() **_ES2015_** //比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。\n12. Object.isExtensible() //判断对象是否可扩展。\n13. Object.isFrozen() //判断对象是否已经冻结。\n14. Object.isSealed() //判断对象是否已经密封。\n15. Object.keys() //返回一个包含所有给定对象自身可枚举属性名称的数组。\n16. Object.preventExtensions() //防止对象的任何扩展。\n17. Object.seal() //防止其他代码删除对象的属性。\n18. Object.setPrototypeOf() **_ES2015_** //设置对象的原型（即内部 [[Prototype]] 属性）。\n19. Object.values() //返回给定对象自身可枚举值的数组。\n\n## Object 实例和 Object 原型对象\n\n> JavaScript 中的所有对象都来自 Object；所有对象从 Object.prototype 继承方法和属性，尽管它们可能被覆盖。\n\n```javascript\nObject.prototype.constructor; //特定的函数，用于创建一个对象的原型。\n```\n\n## 实例方法\n\n1. Object.prototype.hasOwnProperty() //返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。\n2. Object.prototype.isPrototypeOf() //返回一个布尔值，表示指定的对象是否在本对象的原型链中。\n3. Object.prototype.propertyIsEnumerable() //判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。\n4. Object.prototype.toLocaleString() //直接调用 toString()方法。\n5. Object.prototype.toString() //返回对象的字符串表示。\n6. Object.prototype.valueOf() //返回指定对象的原始值。\n\n## 创建对象\n\n```javascript\nconst person = {};\ntypeof person; //object\n```\n\n### 使用 Object 全局函数\n\n```javascript\nconst person = Object();\ntypeof person; //object\n```\n\n### 使用 Object 构造器\n\n```javascript\nconst person = new Object();\ntypeof person; //object\n```\n\n### 使用 Object.create()\n\n```javascript\nconst car = Object.create();\n```\n\n```javascript\nconst person = {\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n};\n\nconst person = Object({\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n});\n\nconst person = new Object({\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n});\n```\n\n### Object.assign\n\n```javascript\nconst copied = Object.assign({}, target1, target2, ...target);\n```\n\n> Object.assign-将一个或多个对象的所有可枚举属性复制到另一个对象中。浅拷贝，复制对象引用而非对象本身。\n\n```javascript\nconst original = {\n  name: 'Fiesta',\n  car: {\n    color: 'blue',\n  },\n};\nconst copied = Object.assign({}, original);\n\noriginal.name = 'Focus';\noriginal.car.color = 'yellow';\n\ncopied.name; //Fiesta\ncopied.car.color; //yellow\n```\n\n### Object.create\n\n```javascript\nconst newObject = Object.create(prototype);\n\nconst newObject = Object.create(prototype, newProperties);\n```\n\n> 使用指定原型创建新的对象，可以指定第二个参数来向对象添加新属性\n\n```javascript\nconst animal = {};\nconst dog = Object.create(animal);\n\nconst animal = {};\nconst dog = Object.create(animal, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n### Object.defineProperty\n\n> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象\n\n```javascript\nconst dog = {};\nObject.defineProperty(dog, 'breed', {\n  value: 'Siberian Husky',\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n扩展：[vue 原理之-神奇的 Object.defineProperty](\"https://zhuanlan.zhihu.com/p/29066270\")\n\n### Object.defineProperties\n\n> 直接在一个对象上定义新的属性或修改现有属性，并返回该对象\n\n```javascript\nconst dog = {};\nObject.defineProperties(dog, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n### Object.entries()\n\n> ES2017,返回自身可枚举属性的键值对数组\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nObject.entries(person); // [['name', 'Fred'], ['age', 87]]\n\nconst people = ['Fred', 'Tony'];\nObject.entries(people); // [['0', 'Fred'], ['1', 'Tony']]\n```\n\n### Object.freeze()\n\n> 冻结对象，冻结后不能再添加或修改\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.freeze(dog);\n\nObject.isFrozen(dog); //true\nObject.isFrozen(myDog); //true\ndog === myDog; //true\n\ndog.name = 'Roger'; //TypeError: 无法添加name属性，dog是不可扩展的\n```\n\n### Object.getOwnPropertyDescriptor()\n\n> 返回自由属性描述符\n\n```javascript\nconst dog = {};\nObject.defineProperties(dog, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nObject.getOwnPropertyDescriptor(dog, 'breed');\n/*\n{\n  value: 'Siberian Husky',\n  writable: false,\n  enumerable: false,\n  configurable: false\n}\n*/\n```\n\n### Object.getOwnPropertyNames()\n\n> 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\ndog.name = 'Roger';\n\nObject.getOwnPropertyNames(dog); //[ 'breed', 'name' ]\n```\n\n### Object.getOwnPropertySymbols()\n\n> 返回一个给定对象自身的所有 Symbol 属性的数\n\n```javascript\nconst dog = {};\nconst r = Symbol('Roger');\nconst s = Symbol('Syd');\ndog[r] = {\n  name: 'Roger',\n  age: 6,\n};\ndog[s] = {\n  name: 'Syd',\n  age: 5,\n};\n\nObject.getOwnPropertySymbols(dog); //[ Symbol(Roger), Symbol(Syd) ]\n```\n\n### Object.getPrototypeOf()\n\n> 返回指定对象的原型（内部[[Prototype]]属性的\n\n```javascript\nconst animal = {};\nconst dog = Object.create(animal);\nconst prot = Object.getPrototypeOf(dog);\n\nanimal === prot; //true\n\n//如果对象没有原型，将返回null\nObject.prototype; //{}\nObject.getPrototypeOf(Object.prototype); //null\n```\n\n### Object.is()\n\n> 判断两个值是否相等\n\n- 两个值都是 undefined\n- 两个值都是 null\n- 两个值都是 true 或者都是 false\n- 两个值是由相同个数的字符按照相同的顺序组成的字符串\n- 两个值指向同一个对象\n- 两个值都是数字并且\n  - 都是正零 +0\n  - 都是负零 -0\n  - 都是 NaN\n  - 都是除零和 NaN 外的其它同一个数字\n\n```javascript\nObject.is(a, b);\n```\n\n### Object.isExtensible()\n\n> 判断一个对象是否是可扩展的，返回布尔值。任何对象都是可扩展，除非使用了 Object.freeze()、Object.seal()、Object.preventExtensions()\n\n### Object.isFrozen()\n\n> 判断一个对象是否被冻结，返回布尔值\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.freeze(dog);\nObject.isFrozen(dog); //true\nObject.isFrozen(myDog); //true\ndog === myDog; //true\n```\n\n### Object.isSealed()\n\n> 判断一个对象是否被密封，返回布尔值\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.seal(dog);\nObject.isSealed(dog); //true\nObject.isSealed(myDog); //true\ndog === myDog; //true\n```\n\n### Object.keys()\n\n> 返回对象的自身可枚举属性组成的数组\n\n```javascript\nconst car = {\n  color: 'Blue',\n  brand: 'Ford',\n  model: 'Fiesta',\n};\n\nObject.keys(car); //[ 'color', 'brand', 'model' ]\n```\n\n### Object.preventExtensions()\n\n> 阻止对象扩展，但可以删除属性\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nObject.preventExtensions(dog);\n\ndog.name = 'Roger'; //TypeError: Cannot add property name, object is not extensible\n\ndelete dog.name;\ndog; //{ breed: 'Siberian Husky' }\n```\n\n### Object.seal()\n\n> 与 Object.freeze（）类似，但不会使属性不可写。仅阻止添加或删除属性。与 Object.preventExtensions（）类似，但也不允许删除属性：\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nObject.seal(dog);\ndog.breed = 'Pug';\ndog.name = 'Roger'; //TypeError: Cannot add property name, object is not extensible\n```\n\n### Object.values()\n\n> 对象自身的所有可枚举属性值的数组\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nObject.values(person); // ['Fred', 87]\n\nconst people = ['Fred', 'Tony'];\nObject.values(people); // ['Fred', 'Tony']\n```\n\n### Object.hasOwnProperty()\n\n> 判断对象自身是否有某个值，返回布尔值\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nperson.hasOwnProperty('name'); //true\nperson.hasOwnProperty('job'); //false\n```\n\n### Object.isPrototypeOf()\n\n> 测试一个对象是否存在于另一个对象的原型链上\n\n```javascript\nconst Animal = {\n  isAnimal: true,\n};\n\nconst Mammal = Object.create(Animal);\nMammal.isMammal = true;\n\nAnimal.isPrototypeOf(Mammal); //true\n\nconst dog = Object.create(Animal);\nObject.setPrototypeOf(dog, Mammal);\n\nAnimal.isPrototypeOf(dog); //true\nMammal.isPrototypeOf(dog); //true\n```\n\n### Object.propertyIsEnumerable()\n\n> 判断对象的属性是否可枚举，返回布尔值\n\n```javascript\nconst person = { name: 'Fred' };\n\nObject.defineProperty(person, 'age', {\n  value: 87,\n  enumerable: false,\n});\n\nperson.propertyIsEnumerable('name'); //true\nperson.propertyIsEnumerable('age'); //false\n```\n\n### Object.toLocaleString()\n\n```javascript\nconst person = { name: 'Fred' };\nperson.toLocaleString(); //[object Object]\n```\n\n### Object.toString()\n\n```javascript\nconst person = { name: 'Fred' };\nperson.toString(); //[object Object]\n```\n\n### Object.valueOf()\n\n> 返回指定对象的原始值\n\n```javascript\nconst person = { name: 'Fred' };\nperson.valueOf(); //{ name: 'Fred' }\n```\n","slug":"javascript/base/Object"},{"data":{"date":"December 6, 2021","title":"Collections of python","tags":["python"],"description":"集合包括列表、字典、集合。","fromNow":"9 days ago"},"content":"\n## 总览\n\n程序员经常会用到的集合，列表、字典、集合。比如：\n\n- 股票池\n- 股票价格\n\n有多种选择来处理这一系列数据：\n\n- 列表。表示一组有序的数据\n- 字典。表示一组键值对的数据\n- 集合。表示一组无序的数据\n\n## 列表\n\n当数据的顺序很重要时，使用列表。记住列表可以容纳任何类型的对象。例如，元组列表。\n\n```python\nportfolio = [\n    ('GOOG', 100, 490.1),\n    ('IBM', 50, 91.3),\n    ('CAT', 150, 83.44)\n]\n\nportfolio[0]            # ('GOOG', 100, 490.1)\nportfolio[2]            # ('CAT', 150, 83.44)\n\n# 列表构造\nrecords=[] #初始化一个空列表\n\nrecords.append(('foo', 1, 2)) #添加元素\nrecords.append(('bar', 'hello')) #添加元素\n\n#从文件读取数据并写入列表\nwith open('data.csv', 'w') as f:\n    next(f) #跳过第一行\n    for line in f:\n        row = line.strip().split(',')\n        records.append((row[0], row[1], row[2]))\n```\n\n## 字典\n\n如果你想要快速随机查找(按键名) ，字典是很有用的。例如，股票价格字典:\n\n```python\nprices = {\n   'GOOG': 513.25,\n   'CAT': 87.22,\n   'IBM': 93.37,\n   'MSFT': 44.12\n}\n\nprices['IBM']           # 93.37\nprices['MSFT']          # 44.12\n\n# 字典构造\nprices = {} #初始化一个空字典\n\nprices['GOOG'] = 513.25 #添加元素\nprices['CAT'] = 87.22 #添加元素\n\n#从文件读取数据并写入字典\nwith open('data.csv', 'w') as f:\n    next(f) #跳过第一行\n    for line in f:\n        row = line.strip().split(',')\n        prices[row[0]] = row[1]\n\n# 字典查找\nif 'GOOG' in prices:\n    print('GOOG is in prices')\n\nname = prices.get('GOOG', 'N/A') #N/A表示默认值\n\nprices.get('GOOG', 0) # 513.25\nprices.get('SCOX', 0) # 0\n\n# 复合键 - 任何类型的数据都可以作为字典的键。例如，元组:\n\nholidays = {\n    (1, 1): 'New Year\\'s Day',\n    (7, 4): 'Independence Day',\n    (12, 25): 'Christmas'\n}\nholidays[(1, 1)] # 'New Year\\'s Day'\n```\n\n## 集合\n\n集合是一种特殊的字典，表示一组无序的数据，数据不重复。\n\n```python\ntech_stocks = {'GOOG', 'IBM', 'CAT'}\ntech_stocks = set(['GOOG', 'IBM', 'CAT'])\n\nnames = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO']\n\nunique = set(names)\n# unique = set(['IBM', 'AAPL','GOOG','YHOO'])\n\nunique.add('CAT')        # Add an item\nunique.remove('YHOO')    # Remove an item\n\ns1 = { 'a', 'b', 'c'}\ns2 = { 'c', 'd' }\ns1 | s2                 # Set union { 'a', 'b', 'c', 'd' }\ns1 & s2                 # Set intersection { 'c' }\ns1 - s2                 # Set difference { 'a', 'b' }\n\n```\n","slug":"python/2.2-containers"},{"data":{"date":"May 19, 2020","title":"理解函数的执行过程","tags":["javascript"],"fromNow":"2 years ago"},"content":"","slug":"javascript/advance/理解函数的执行过程"},{"data":{"date":"May 19, 2020","title":"面试题-手写instanceof","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n## 实现 instanceof\n\n> 核心考察点 [getPrototypeOf](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf)\n\n```javascript\nfunction _instanceof(left, right) {\n  if (left !== 'object' || left === null) return false;\n  const proto = Object.getPrototypeOf(left);\n  while (true) {\n    if (proto === null) return false;\n    if (proto === right.prototype) return true;\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n_instanceof(111, Number); //true\n_instanceof(new String('11'), String); //true\n```\n","slug":"interview/js/instanceof"},{"data":{"date":"April 12, 2021","title":"什么是React","tags":["react","javascript"],"description":"React是一个JavaScript库，致力于使UI开发变得简单","fromNow":"8 months ago"},"content":"\n![xCOR7k](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/xCOR7k.jpg)\n\nReact 最初是由 Facebook 开发的，旨在解决他们面临的前端问题：\n\n1. DOM 操作是极其昂贵的\n\n2. 当时没有专门处理前端库的库（Angular）\n\n3. 使用大量 jQuery 会导致代码混乱而且难以理解\n\n2013 年，React 以开源库的形式发布，从那时起，它就受到了社区的广泛喜爱。\n\n为什么开发人员喜欢 React？总结有几个原因：\n\n启动 React 很简单，运行 React 并不容易，因为它使用 JavaScript 渲染视图。你需要了解 Webpack 及其配置，需要了解 babel、eslint 等。但是 Facebook 为我们提供了`create-react-app`，可以快速开始 react 开发。\n\n从本质上讲，这是极简主义的，React 只处理一件事：UI。我们可以将 React 视为 MVC 框架中的`V`。\n\n强大的社区支持为了增强 React 的功能，开源贡献者已经建立了一个令人惊叹的库生态系统，使我们能够开发更强大的应用程序。\n\n最重要的是，React 的学习曲线很小，可为提供令人难以置信的强大功能，UI 灵活，可重用和可控制。\n\nReact 中必须掌握的核心概念：\n\n- 组件`component`\n- jsx\n- 状态`state`\n- 属性`props`\n\n## 入门\n\n创建一个简单的 React 应用\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Simple React.js application</title>\n  </head>\n  <body>\n    <h2>Simple React.js application</h2>\n\n    <div id=\"show_button_container\"></div>\n\n    <script\n      src=\"https://unpkg.com/react@16/umd/react.development.js\"\n      crossorigin\n    ></script>\n    <script\n      src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"\n      crossorigin\n    ></script>\n\n    <script>\n      'use strict';\n      const e = React.createElement;\n\n      class ShowButton extends React.Component {\n        render() {\n          return e('button', { onClick: () => alert('Hello there!') }, 'Show');\n        }\n      }\n\n      const domContainer = document.querySelector('#show_button_container');\n      ReactDOM.render(e(ShowButton), domContainer);\n    </script>\n  </body>\n</html>\n```\n","slug":"react/什么是react"}]},"__N_SSG":true}