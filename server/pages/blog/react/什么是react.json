{"pageProps":{"data":{"date":"April 12, 2021","title":"什么是React","tags":["react","javascript"],"description":"React是一个JavaScript库，致力于使UI开发变得简单","fromNow":"8 months ago"},"content":{"compiledSource":"var s=Object.defineProperty,d=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,p=(e,t)=>{for(var a in t||(t={}))o.call(t,a)&&l(e,a,t[a]);if(i)for(var a of i(t))r.call(t,a)&&l(e,a,t[a]);return e},c=(e,t)=>d(e,u(t));var m=(e,t)=>{var a={};for(var n in e)o.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&i)for(var n of i(e))t.indexOf(n)<0&&r.call(e,n)&&(a[n]=e[n]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=m(n,[\"components\"]);return mdx(MDXLayout,c(p(p({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"img\",p({parentName:\"p\"},{src:\"https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/xCOR7k.jpg\",alt:\"xCOR7k\"}))),mdx(\"p\",null,\"React \\u6700\\u521D\\u662F\\u7531 Facebook \\u5F00\\u53D1\\u7684\\uFF0C\\u65E8\\u5728\\u89E3\\u51B3\\u4ED6\\u4EEC\\u9762\\u4E34\\u7684\\u524D\\u7AEF\\u95EE\\u9898\\uFF1A\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},mdx(\"p\",{parentName:\"li\"},\"DOM \\u64CD\\u4F5C\\u662F\\u6781\\u5176\\u6602\\u8D35\\u7684\")),mdx(\"li\",{parentName:\"ol\"},mdx(\"p\",{parentName:\"li\"},\"\\u5F53\\u65F6\\u6CA1\\u6709\\u4E13\\u95E8\\u5904\\u7406\\u524D\\u7AEF\\u5E93\\u7684\\u5E93\\uFF08Angular\\uFF09\")),mdx(\"li\",{parentName:\"ol\"},mdx(\"p\",{parentName:\"li\"},\"\\u4F7F\\u7528\\u5927\\u91CF jQuery \\u4F1A\\u5BFC\\u81F4\\u4EE3\\u7801\\u6DF7\\u4E71\\u800C\\u4E14\\u96BE\\u4EE5\\u7406\\u89E3\"))),mdx(\"p\",null,\"2013 \\u5E74\\uFF0CReact \\u4EE5\\u5F00\\u6E90\\u5E93\\u7684\\u5F62\\u5F0F\\u53D1\\u5E03\\uFF0C\\u4ECE\\u90A3\\u65F6\\u8D77\\uFF0C\\u5B83\\u5C31\\u53D7\\u5230\\u4E86\\u793E\\u533A\\u7684\\u5E7F\\u6CDB\\u559C\\u7231\\u3002\"),mdx(\"p\",null,\"\\u4E3A\\u4EC0\\u4E48\\u5F00\\u53D1\\u4EBA\\u5458\\u559C\\u6B22 React\\uFF1F\\u603B\\u7ED3\\u6709\\u51E0\\u4E2A\\u539F\\u56E0\\uFF1A\"),mdx(\"p\",null,\"\\u542F\\u52A8 React \\u5F88\\u7B80\\u5355\\uFF0C\\u8FD0\\u884C React \\u5E76\\u4E0D\\u5BB9\\u6613\\uFF0C\\u56E0\\u4E3A\\u5B83\\u4F7F\\u7528 JavaScript \\u6E32\\u67D3\\u89C6\\u56FE\\u3002\\u4F60\\u9700\\u8981\\u4E86\\u89E3 Webpack \\u53CA\\u5176\\u914D\\u7F6E\\uFF0C\\u9700\\u8981\\u4E86\\u89E3 babel\\u3001eslint \\u7B49\\u3002\\u4F46\\u662F Facebook \\u4E3A\\u6211\\u4EEC\\u63D0\\u4F9B\\u4E86\",mdx(\"inlineCode\",{parentName:\"p\"},\"create-react-app\"),\"\\uFF0C\\u53EF\\u4EE5\\u5FEB\\u901F\\u5F00\\u59CB react \\u5F00\\u53D1\\u3002\"),mdx(\"p\",null,\"\\u4ECE\\u672C\\u8D28\\u4E0A\\u8BB2\\uFF0C\\u8FD9\\u662F\\u6781\\u7B80\\u4E3B\\u4E49\\u7684\\uFF0CReact \\u53EA\\u5904\\u7406\\u4E00\\u4EF6\\u4E8B\\uFF1AUI\\u3002\\u6211\\u4EEC\\u53EF\\u4EE5\\u5C06 React \\u89C6\\u4E3A MVC \\u6846\\u67B6\\u4E2D\\u7684\",mdx(\"inlineCode\",{parentName:\"p\"},\"V\"),\"\\u3002\"),mdx(\"p\",null,\"\\u5F3A\\u5927\\u7684\\u793E\\u533A\\u652F\\u6301\\u4E3A\\u4E86\\u589E\\u5F3A React \\u7684\\u529F\\u80FD\\uFF0C\\u5F00\\u6E90\\u8D21\\u732E\\u8005\\u5DF2\\u7ECF\\u5EFA\\u7ACB\\u4E86\\u4E00\\u4E2A\\u4EE4\\u4EBA\\u60CA\\u53F9\\u7684\\u5E93\\u751F\\u6001\\u7CFB\\u7EDF\\uFF0C\\u4F7F\\u6211\\u4EEC\\u80FD\\u591F\\u5F00\\u53D1\\u66F4\\u5F3A\\u5927\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\\u3002\"),mdx(\"p\",null,\"\\u6700\\u91CD\\u8981\\u7684\\u662F\\uFF0CReact \\u7684\\u5B66\\u4E60\\u66F2\\u7EBF\\u5F88\\u5C0F\\uFF0C\\u53EF\\u4E3A\\u63D0\\u4F9B\\u4EE4\\u4EBA\\u96BE\\u4EE5\\u7F6E\\u4FE1\\u7684\\u5F3A\\u5927\\u529F\\u80FD\\uFF0CUI \\u7075\\u6D3B\\uFF0C\\u53EF\\u91CD\\u7528\\u548C\\u53EF\\u63A7\\u5236\\u3002\"),mdx(\"p\",null,\"React \\u4E2D\\u5FC5\\u987B\\u638C\\u63E1\\u7684\\u6838\\u5FC3\\u6982\\u5FF5\\uFF1A\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\u7EC4\\u4EF6\",mdx(\"inlineCode\",{parentName:\"li\"},\"component\")),mdx(\"li\",{parentName:\"ul\"},\"jsx\"),mdx(\"li\",{parentName:\"ul\"},\"\\u72B6\\u6001\",mdx(\"inlineCode\",{parentName:\"li\"},\"state\")),mdx(\"li\",{parentName:\"ul\"},\"\\u5C5E\\u6027\",mdx(\"inlineCode\",{parentName:\"li\"},\"props\"))),mdx(\"h2\",null,\"\\u5165\\u95E8\"),mdx(\"p\",null,\"\\u521B\\u5EFA\\u4E00\\u4E2A\\u7B80\\u5355\\u7684 React \\u5E94\\u7528\"),mdx(\"pre\",null,mdx(\"code\",p({parentName:\"pre\"},{className:\"language-html\"}),`<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Simple React.js application</title>\n  </head>\n  <body>\n    <h2>Simple React.js application</h2>\n\n    <div id=\"show_button_container\"></div>\n\n    <script\n      src=\"https://unpkg.com/react@16/umd/react.development.js\"\n      crossorigin\n    ><\\/script>\n    <script\n      src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"\n      crossorigin\n    ><\\/script>\n\n    <script>\n      'use strict';\n      const e = React.createElement;\n\n      class ShowButton extends React.Component {\n        render() {\n          return e('button', { onClick: () => alert('Hello there!') }, 'Show');\n        }\n      }\n\n      const domContainer = document.querySelector('#show_button_container');\n      ReactDOM.render(e(ShowButton), domContainer);\n    <\\/script>\n  </body>\n</html>\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"April 12, 2021","title":"什么是React","tags":["react","javascript"],"description":"React是一个JavaScript库，致力于使UI开发变得简单","fromNow":"8 months ago"}},"randomPost":[{"data":{"date":"January 19, 2020","title":"使用js获取位置","tags":["i18n","javascript"],"fromNow":"2 years ago"},"content":"\n![quick-tip-detecting-your-location-with-javascript](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20190121163457.png)\n\n首先，我们使用 caniuse-cmd 查看下 geolocation 的兼容性,几乎所有的现代浏览器都支持 geolocation\n\nGeolocation 通过使用 GPS、WIFI、IP 地址检测自己的位置信息，开发人员可使用这些信息给用户提供更好的搜索建议，比如附近的便利店，并实现互动。\n\n本地资源（location sources） JavaScript 提供了一个简单，但功能强大的工具来定位设备的地理定位 API 的形式。它包括一个小的一组易于使用的方法，可以获得设备的位置：\n\nGPS-主要在移动设备，精确到 10 米 WIFI-几乎所有的联网设备 IP-仅限于区域，备选方案采用哪种方案取决于浏览器支持，一般情况下 WIFI 快于 GPS 快于 IP\n\n使用 geolocation api 通过使用 caniuse-cmd，我们知道大部分浏览器支持 geolocation，但我们需要做好判断，请确保可以正常使用 geolocation\n\n```javascript\nif (navigator.geolocation) {\n  // 支持geolocation\n} else {\n  // 不支持geolocation\n}\n```\n\nnavigator.geolocation 有如下几个方法：\n\n- Geolocation.getCurrentPosition() //获取当前位置\n- Geolocation.watchPosition() //监测定位\n- Geolocation.clearWatch() //清除监测\n\ngetCurrentPosition() and watchPosition() methods 的工作方式是基本相同的。这两方法目的基本相同，都是用来去获取 device 的位置信息吧， 都是以一个异步的工作形式来获取位置信息的， 他们也都依赖于一个 attempt call 的结果\n\n```javascript\nnavigator.geolocation.getCurrentPosition(\n\n    // 位置获取成功\n    function(position) {\n\n        position = {\n            coords: {\n                latitude - //纬度.\n                longitude - //经度.\n                altitude - //高度.\n                accuracy - //精确度.\n                altitudeAccuracy - //高度的准确性.\n                heading - //.\n                speed - //.\n            }\n            timestamp - //时间戳.\n        }\n\n    },\n\n    // 位置获取失败\n    function(error){\n\n    }\n);\n```\n\n如上，使用 geolocation api 很简单，只需要正确调用方法，等待返回坐标即可。\n\n用户权限由于 geolocation api 会暴露用户信息，所以当应用程序访问的时候，将以弹窗请求用户操作，如下\n\n主机安全另一个保护措施是使用 HTTPS 连接。由于一个新的网络安全策略，谷歌浏览器（桌面版和手机版）不再允许非安全的主机上运行的 geolocation api。使用 https 可以最大限度的减少数据信息的盗用或被滥用的风险。\n\n这里查看更多关于这个问题。\n\n```javascript\n一个简单的Demo;\nfindMeButton.on('click', function () {\n  navigator.geolocation.getCurrentPosition(function (position) {\n    // Get the coordinates of the current position.\n    var lat = position.coords.latitude;\n    var lng = position.coords.longitude;\n\n    // Create a new map and place a marker at the device location.\n    var map = new GMaps({\n      el: '#map',\n      lat: lat,\n      lng: lng,\n    });\n\n    map.addMarker({\n      lat: lat,\n      lng: lng,\n    });\n  });\n});\n```\n\n[在线 demo](https://jsfiddle.net/dannymarkov/ubrvm4ao/ 'https://jsfiddle.net/dannymarkov/ubrvm4ao/')\n\n翻译自[Detecting Your Location With JavaScript](http://tutorialzine.com/2016/06/quick-tip-detecting-your-location-with-javascript/ 'http://tutorialzine.com/2016/06/quick-tip-detecting-your-location-with-javascript/')\n","slug":"translate/使用js获取位置"},{"data":{"date":"October 19, 2019","title":"安装mongodb","tags":["server"],"fromNow":"2 years ago"},"content":"\n## 安装 mongodb\n\n## 添加 mongodb 源\n\n```bash\nsudo vi /etc/yum.repos.d/mongodb-org.repo\n\n\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n```bash\nyum repolist\n```\n\n## 安装 mongodb\n\n```bash\nsudo yum install mongodb-org\n\n启动\nsudo systemctl start mongod\n\n重载\nsudo systemctl reload mongod\n\n停止\nsudo systemctl stop mongod\n\n重启\nsudo systemctl restart mongod\n\n加入自启\nsudo systemctl enable mongod\n\n检查状态\nsystemctl status mongod\n\n```\n","slug":"server/安装mongodb"},{"data":{"date":"April 8, 2021","title":"函数、参数、错误","tags":["swift"],"description":"一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。","fromNow":"8 months ago"},"content":"\n## 创建函数\n\nSwift 函数从 func 关键字开始，然后是函数名，然后`{}`。函数的所有主体——都放在大括号内。\n\n```swift\n// 创建函数\nfunc printHelp() {\n    let message = \"\"\"\n\t\tWelcome to MyApp!\n\n\t\tRun this app inside a directory of images and\n\t\tMyApp will resize them all into thumbnails\n\t\t\"\"\"\n    print(message)\n}\n// 调用函数printHelp\nprintHelp()\n```\n\n## 接收参数\n\n函数接收参数，比如内置的`print`函数，参数定义数据类型表示接收的参数类型。\n\n```swift\nprint(\"hello world\") // hello world即为参数\n```\n\n创建函数打印平方值\n\n```swift\nfunc square(number: Int) {\n    print(number * number)\n}\n// Int 表示参数只接受Int类型\nsquare(number: 8) // 64\n```\n\n## 返回值\n\n除了接收数据，函数还可以返回数据。通过`-> <数据类型>`告诉 swift 将返回什么数据类型的值。\n\n```swift\nfunc square(number: Int) -> Int {\n    return number * number\n}\n// -> Int 表示将返回Int类型的值\nlet result = square(number: 8)\nprint(result) // 64\n```\n\n## 参数标签\n\n每一个函数的形式参数都包含形式参数标签和形式参数名两部分\n\n- 形式参数标签用在调用函数的时候\n- 形式参数名用在函数的实现当中\n- 在调用函数的时候，每一个形式参数前边都会有一个形式参数标签\n- 默认情况下，形式参数使用它们的形式参数名作为形式参数标签\n- 如果不想要形式参数标签，可以在形式参数名称前加上`_`\n\n```swift\n//这里的info1和info2就是形式参数标签\n//name和age是形式参数名称\nfunc personalInfo(info1 name : String, info2 age : Int) { //在函数的实现中使用形式参数名称 print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候使用形式参数标签\npersonalInfo(info1: \"norman\", info2: 23)\n\n//下面是默认写法\n//此时，name和age既是形式参数标签，也是形式参数名称\nfunc personalInfo(name : String, age : Int) { //在函数内部实现的时候，name和age是形式参数名称 print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候，name和age是形式参数标签\npersonalInfo(name: \"norman\", age: 24)\n\n//如果不想要形式参数标签，可以在形式参数名称前面加 _\nfunc personalInfo(_ name : String, _ age : Int) { print(\"姓名：(name)，年龄：(age)\")\n}\n//在函数调用的时候，没有形式参数标签\npersonalInfo(\"norman\", 24)\n```\n\n## 默认参数\n\nswift 允许设置参数默认值，如：\n\n```swift\nfunc greet(_ person: String, nicely: Bool = true) {\n    if nicely == true {\n        print(\"Hello, \\(person)!\")\n    } else {\n        print(\"Oh no, it's \\(person) again...\")\n    }\n}\n\n// 调用\ngreet(\"Taylor\")\ngreet(\"Taylor\", nicely: false)\n```\n\n## 变量参数\n\n当参数不确定，或者参数有多个，在类型后使用`...`，swift 会将传入的值转换为数组，因此可以在函数内部使用循环语句处理。如：\n\n```swift\nfunc square(numbers: Int...) {\n    for number in numbers {\n        print(\"\\(number) squared is \\(number * number)\")\n    }\n}\n\nsquare(numbers: 1, 2, 3, 4, 5)\n```\n\n## io 参数\n\n一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值。\n\n如果想要声明一个变量参数，可以在参数定义前加 inout 关键字，这样就可以改变这个参数的值了。\n\n比如，如果你想将一个数字翻倍——即直接更改值，而不是返回一个新的值——你可以写一个这样的函数：\n\n```swift\nfunc doubleInPlace(number: inout Int) {\n    number *= 2\n}\n\nvar myNum = 10\ndoubleInPlace(number: &myNum)\n```\n\n## 函数总结\n\n- 函数允许我们重复使用代码，而不需要重复声明。\n- 函数可以接受参数——只需告诉 Swift 每个参数的类型。\n- 函数可以返回值，同样，您只需指定要返回的类型。如果您想返回一些内容，可以使用元组。\n- 可以在内部和外部对参数使用不同的名称，也可以完全忽略外部名称。\n- 参数可以具有默认值，这有助于在通常使用特定值时编写更少的代码。\n- 可变参数函数接受零个或多个特定参数，Swift 将输入转换为数组。\n- 函数可以抛出错误，但必须使用 try 和 handle errors 来调用它们。\n- 可以使用 inout 来更改函数内部的变量，但通常最好是返回一个新值。\n","slug":"swift/100days/day05"},{"data":{"date":"April 12, 2018","title":"Flexbox指南","tags":["css"],"description":"Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。","fromNow":"4 years ago"},"content":"\n![Flexbox](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181016105026.png)\n\nFlexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。\n\n- 基本介绍\n- 浏览器兼容性\n- 启用 Flexbox\n- 容器属性\n  - 行||列 对齐 ==row and columns==\n  - 水平||垂直 对齐 ==Vertical and horizontal==\n  - 更改水平对齐 ==change horizontal alignment==\n  - 更改垂直对齐 ==change vertical alignment==\n    - 关于基准线 ==about baseline==\n  - 换行 ==wrap==\n- flex 元素上的属性\n  - order\n  - align-self\n  - flex-grow\n  - flex-shrink\n  - flex-basis\n  - flex\n\n### 介绍\n\nFlexbox，也称为灵活盒模块，是两个现代布局系统之一，还有 CSS Grid。与 CSS Grid（二维）相比，flexbox 是一维布局模型。它将基于行或列控制布局，但不能同时控制布局。flexbox 的主要目标是允许项目填充其容器提供的整个空间，具体取决于您设置的一些规则。Flexbox 不兼容 IE10 以下，IE10 以下可以使用如下方式：\n\n- Table layouts\n- Floats\n- clearfix hacks\n- display: table hacks\n\n### 兼容性\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205051.png)\n\nIE10 以下不兼容，一些浏览器需要使用-webkit 或者 display:-webkit-box 兼容处理。\n\n### 使用 flexbox\n\n```css\ndisplay: flexbox;\n```\n\n或者\n\n```css\ndisplay: inline-flexbox;\n```\n\n### 容器属性\n\n- flex-direction\n- justify-content\n- align-items\n- flex-wrap\n- flex-flow\n\n### 行对齐或者列对齐\n\nflex-direction 决定容器以行对齐还是列对齐。\n\n- flex-direction:row，行对齐，从左到右\n- flex-direction:row-reverse，行对齐，从右到左\n- flex-direction:column，列对齐，从上到下\n- flex-direction:column-reverse，列对齐，从下到上\n\n如下图所示：\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181020205713.png)\n\n### 水平对齐或者垂直对齐\n\nflex-direction 默认是 row，从左向右，当其属性值为 column 时，是从上到下，可以使用 justify-content 和 align-items 改变水平和垂直对齐。\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100130.png)\n\n### 改变水平对齐方式\n\njustify-content 有 5 个属性值：\n\n1. flex-start 左对齐\n2. flex-end 右对齐\n3. center 居中对齐\n4. space-between 首尾对齐容器左右侧，中间间距相等\n5. space-around 每个元素的间距相等\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/20181022100921.png)\n\n### 改变垂直对齐方式\n\nalign-items 有 5 个属性值：\n\n1. flex-start 顶部对齐\n2. flex-end 底部对齐\n3. center 居中对齐\n4. baseline 基线对齐\n5. stretch 拉伸以适应容器\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022141409.png)\n\n关于 align-items:baseline，可以看看 codepen：[https://codepen.io/flaviocopes/pen/oExoJR](https://codepen.io/flaviocopes/pen/oExoJR)\n\n### 换行\n\n默认情况下，flexbox 容器中的项目保留在一行中，缩小它们以适合容器。\n\n可以使用 flex-wrap:wrap 或者 flex-wrap:wrap-reverse 对容器中的元素进行换行处理。\n\n一种简写方式：flex-flow:row wrap;即 flex-direction:row && flex-wrap:wrap\n\n### 适用于 flexbox 容器内每个元素的属性\n\n1. order\n2. align-self\n3. flex-grow\n4. flex-shrink\n5. flex-basis\n6. flex\n\n#### order-改变元素的顺序，如下图所示，可以指定某个元素的 order 值，以改变其位置，默认值为 0\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142507.png)\n\n#### align-self-元素使用 align-self 覆盖容器的 align-items 对当前元素的对齐方式\n\n![image](https://cdn.jsdelivr.net/gh/funnypan/pics@master/images/20181022142842.png)\n\n#### flex-grow || flex-shrink 如有必要，可以增加或缩小某个元素\n\nflex-grow：默认值为 0，当某个元素 flex-grow 为 1，另一个为 2，则为 flex-grow：2 的元素占用 flex-grow:1 的空间的 2 倍。\n\nflex-shrink：默认值为 1，如果没有显示定义该属性，将会自动按照默认值 1 在所有因子相加之后计算比率来进行空间收缩。\n\n比如：有这么一个容器，div>.box1*3+.box2*2 父容器定义宽度为 500px，子元素定义宽度为 120px，box1 的 flex-shrink 为 1，.box2 的 flex-shrink 为 2，那么子项相加之后即为 600 px，超出父容器 100px。那么超出的 100px 需要被 A、B、C、D、E 消化 通过收缩因子，所以加权综合可得 100*1+100*1+100*1+100*2+100\\*2=700px。\n\n```\n于是我们可以计算 A、B、C、D、E 将被移除的溢出量是多少：\nA 被移除溢出量：(100*1/700)*100，即约等于14px\nB 被移除溢出量：(100*1/700)*100，即约等于14px\nC 被移除溢出量：(100*1/700)*100，即约等于14px\nD 被移除溢出量：(100*2/700)*100，即约等于28px\nE 被移除溢出量：(100*2/700)*100，即约等于28px\n\n最后A、B、C、D、E的实际宽度分别为：120-14=106px, 120-14=106px, 120-14=106px, 120-28=92px,120-28=92px\n```\n\n#### flex-basis-用于设置或检索弹性盒伸缩基准值，默认值为 auto，其与 width 的区别可以参考这篇文章：https://www.jianshu.com/p/17b1b445ecd4\n\n#### flex：有三个属性值\n\n1. flex-grow\n2. flex-shrink\n3. flex-basis\n\n```css\nflex: 0 1 auto 分别对应flex-grow、flex-shrink、flex-basis;\n```\n\n## 结尾\n\n友情献上小游戏，通过游戏学习 flexbox\n\nhttp://flexboxfroggy.com/#zh-cn\n","slug":"css/Flexbox指南"},{"data":{"date":"December 6, 2021","title":"Collections of python","tags":["python"],"description":"集合包括列表、字典、集合。","fromNow":"9 days ago"},"content":"\n## 总览\n\n程序员经常会用到的集合，列表、字典、集合。比如：\n\n- 股票池\n- 股票价格\n\n有多种选择来处理这一系列数据：\n\n- 列表。表示一组有序的数据\n- 字典。表示一组键值对的数据\n- 集合。表示一组无序的数据\n\n## 列表\n\n当数据的顺序很重要时，使用列表。记住列表可以容纳任何类型的对象。例如，元组列表。\n\n```python\nportfolio = [\n    ('GOOG', 100, 490.1),\n    ('IBM', 50, 91.3),\n    ('CAT', 150, 83.44)\n]\n\nportfolio[0]            # ('GOOG', 100, 490.1)\nportfolio[2]            # ('CAT', 150, 83.44)\n\n# 列表构造\nrecords=[] #初始化一个空列表\n\nrecords.append(('foo', 1, 2)) #添加元素\nrecords.append(('bar', 'hello')) #添加元素\n\n#从文件读取数据并写入列表\nwith open('data.csv', 'w') as f:\n    next(f) #跳过第一行\n    for line in f:\n        row = line.strip().split(',')\n        records.append((row[0], row[1], row[2]))\n```\n\n## 字典\n\n如果你想要快速随机查找(按键名) ，字典是很有用的。例如，股票价格字典:\n\n```python\nprices = {\n   'GOOG': 513.25,\n   'CAT': 87.22,\n   'IBM': 93.37,\n   'MSFT': 44.12\n}\n\nprices['IBM']           # 93.37\nprices['MSFT']          # 44.12\n\n# 字典构造\nprices = {} #初始化一个空字典\n\nprices['GOOG'] = 513.25 #添加元素\nprices['CAT'] = 87.22 #添加元素\n\n#从文件读取数据并写入字典\nwith open('data.csv', 'w') as f:\n    next(f) #跳过第一行\n    for line in f:\n        row = line.strip().split(',')\n        prices[row[0]] = row[1]\n\n# 字典查找\nif 'GOOG' in prices:\n    print('GOOG is in prices')\n\nname = prices.get('GOOG', 'N/A') #N/A表示默认值\n\nprices.get('GOOG', 0) # 513.25\nprices.get('SCOX', 0) # 0\n\n# 复合键 - 任何类型的数据都可以作为字典的键。例如，元组:\n\nholidays = {\n    (1, 1): 'New Year\\'s Day',\n    (7, 4): 'Independence Day',\n    (12, 25): 'Christmas'\n}\nholidays[(1, 1)] # 'New Year\\'s Day'\n```\n\n## 集合\n\n集合是一种特殊的字典，表示一组无序的数据，数据不重复。\n\n```python\ntech_stocks = {'GOOG', 'IBM', 'CAT'}\ntech_stocks = set(['GOOG', 'IBM', 'CAT'])\n\nnames = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO']\n\nunique = set(names)\n# unique = set(['IBM', 'AAPL','GOOG','YHOO'])\n\nunique.add('CAT')        # Add an item\nunique.remove('YHOO')    # Remove an item\n\ns1 = { 'a', 'b', 'c'}\ns2 = { 'c', 'd' }\ns1 | s2                 # Set union { 'a', 'b', 'c', 'd' }\ns1 & s2                 # Set intersection { 'c' }\ns1 - s2                 # Set difference { 'a', 'b' }\n\n```\n","slug":"python/2.2-containers"},{"data":{"date":"November 20, 2021","title":"Numbers","tags":["python"],"description":"关于数学运算","fromNow":"25 days ago"},"content":"\n## Numbers 类型\n\n> python 有 4 种数字类型\n\n- Boolean\n- Integer\n- Float\n- Complex\n\n### Boolean\n\n布尔值，只有 True 和 False 两个值，可以用来表示真假。\n\n```python\na=True\nb=False\n```\n\n在数学运算种，布尔值的值只有 0 和 1，0 表示 False，1 表示 True。\n\n```python\nc=4+True #5\nd=False\nif d==0:\n    print('d is zero')\nelse:\n    print('d is not zero')\n```\n\n### Integer\n\n```python\na = 37\nb = -299392993727716627377128481812241231\nc = 0x7fa8      # Hexadecimal\nd = 0o253       # Octal\ne = 0b10001111  # Binary\n```\n\n### Float\n\n```python\n>>> a = 2.1 + 4.2\n>>> a == 6.3\nFalse\n>>> a\n6.300000000000001\n>>>\n```\n\n### 比较 Comparisons\n\npython 有如下比较运算符：\n\n```python\nx < y      Less than\nx <= y     Less than or equal\nx > y      Greater than\nx >= y     Greater than or equal\nx == y     Equal to\nx != y     Not equal to\n\n#布尔值操作\nif b >= a and b <= c:\n    print('b is between a and c')\n\nif not (b < a or b > c):\n    print('b is still between a and c')\n```\n\n### 数字转换\n\n使用类型名转换数字，如下：\n\n```python\na = int(3.14)\nb = float(3)\n```\n","slug":"python/1.2-numbers"}]},"__N_SSG":true}