{"pageProps":{"data":{"date":"May 19, 2020","title":"强制类型转换","tags":["javascript"],"fromNow":"2 years ago"},"content":{"compiledSource":"var M=Object.defineProperty,X=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var u=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;var s=(o,t,n)=>t in o?M(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n,p=(o,t)=>{for(var n in t||(t={}))r.call(t,n)&&s(o,n,t[n]);if(u)for(var n of u(t))a.call(t,n)&&s(o,n,t[n]);return o},y=(o,t)=>X(o,c(t));var D=(o,t)=>{var n={};for(var e in o)r.call(o,e)&&t.indexOf(e)<0&&(n[e]=o[e]);if(o!=null&&u)for(var e of u(o))t.indexOf(e)<0&&a.call(o,e)&&(n[e]=o[e]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var e=n,{components:o}=e,t=D(e,[\"components\"]);return mdx(MDXLayout,y(p(p({},layoutProps),t),{components:o,mdxType:\"MDXLayout\"}))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"May 19, 2020","title":"强制类型转换","tags":["javascript"],"fromNow":"2 years ago"}},"randomPost":[{"data":{"date":"April 28, 2021","title":"React State","tags":["react","javascript"],"description":"如何在 React.js 中处理状态","fromNow":"8 months ago"},"content":"\n`state`是`React`组件中的内置对象\n\n在`state`对象中，我们存储属于组件的属性值。当状态对象更改时，组件重新渲染。使用`setState()`函数修改`state`对象。`state`和`props`类似，区别在于`props`被传递给组件，而`state`在组件中进行管理。开发人员应该始终尝试使状态最小化。此外，有状态组件的数量应该最小化。\n\n## 使用`create-react-app`创建应用\n\n```shell\nnpx create-react-app state-demo\ncd state-demo\n```\n\n```jsx\n//App.js\nimport React from 'react';\n\nclass App extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      title: 'React state example',\n    };\n  }\n\n  tooggleTitle = () => {\n    if (this.state.title === '') {\n      this.setState({ title: 'React state example' });\n    } else {\n      this.setState({ title: '' });\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <div>\n          <input\n            type=\"checkbox\"\n            id=\"showTitle\"\n            onClick={this.tooggleTitle}\n            defaultChecked\n          />\n          <label htmlFor=\"showTitle\">Show title</label>\n        </div>\n\n        <h2>{this.state.title}</h2>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n在这里创建一个简单的`state`，用来存储`title`的属性\n\n`toggleTitle`函数切换`title`的值\n\n<CodeSandbox codeSandboxId=\"white-worker-4r3bv\" />\n\n[在线地址](https://csb-4r3bv.netlify.app/)\n","slug":"react/state"},{"data":{"date":"October 9, 2020","title":"Linux命令gzip","tags":["linux"],"description":"“gzip”命令的快速指南，用于压缩文件","fromNow":"a year ago"},"content":"\n“gzip”命令的快速指南，用于压缩文件\n\ngzip 命令可以在 Linux、macOS、WSL 和任何有 UNIX 环境的地方使用。\n\n您可以使用 gzip 命令使用名为[LZ77](https://en.wikipedia.org/wiki/LZ77_and_LZ78)的 gzip 压缩协议压缩文件。\n\n## 使用方法\n\n```shell\ngzip filename\n```\n\n这将压缩文件，并向其附加一个.gz 扩展名，原始文件将被删除。为了防止出现这种情况，可以使用`-C`选项并使用输出重定向将输出写入文件名.gz 文件：\n\n```shell\ngzip -c filename > filename.gz\n```\n\n-C 选项指定输出将转到标准输出流，保留原始文件不变\n\n同时也可以使用-K 选项\n\n```shell\ngzip -k filename\n```\n\n压缩越多，压缩（和解压缩）所需的时间就越长。级别范围从 1（最快、最差的压缩）到 9（最慢、更好的压缩），默认值为 6。您可以使用-`<NUMBER>`选项选择特定级别：\n\n```shell\ngzip -1 filename\n```\n\n压缩多文件\n\n```shell\ngzip filename1 filename2\n```\n\n使用-r 选项递归地压缩目录中的所有文件：\n\n```shell\ngzip -r a_folder\n```\n\n-v 选项打印压缩百分比信息。下面是一个与-k（keep）选项一起使用的示例：\n\n![fvzBBf](https://cdn.jsdelivr.net/gh/funnyPan/pics@master/uPic/fvzBBf.png)\n\ngzip 还可以用于解压缩文件，使用-d 选项：\n\n```shell\ngzip -d filename.gz\n```\n","slug":"linux/Linux命令-gzip"},{"data":{"date":"May 12, 2018","title":"Object","tags":["javascript"],"fromNow":"4 years ago"},"content":"\n## Object\n\n> 任何非原始类型的值（字符串，数字，布尔值，符号，null 或未定义）都是对象，数组和函数也不例外。\n\n## 内置属性\n\n1. Object.length=1\n2. Object.prototype\n\n## 静态方法\n\n1. Object.assign() **_ES2015_** //通过复制一个或多个对象来创建一个新的对象。\n2. Object.create() //使用指定的原型对象和属性创建一个新对象。\n3. Object.defineProperty() //给对象添加一个属性并指定该属性的配置。\n4. Object.defineProperties() //给对象添加多个属性并分别指定它们的配置。\n5. Object.entries() **_ES2017_** //返回给定对象自身可枚举属性的 [key, value] 数组。\n6. Object.freeze() //冻结对象：其他代码不能删除或更改任何属性。\n7. Object.getOwnPropertyDescriptor() //返回对象指定的属性配置。\n8. Object.getOwnPropertyNames() //返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。\n9. Object.getOwnPropertySymbols() //返回一个数组，它包含了指定对象自身所有的符号属性。\n10. Object.getPrototypeOf() //返回指定对象的原型对象。\n11. Object.is() **_ES2015_** //比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。\n12. Object.isExtensible() //判断对象是否可扩展。\n13. Object.isFrozen() //判断对象是否已经冻结。\n14. Object.isSealed() //判断对象是否已经密封。\n15. Object.keys() //返回一个包含所有给定对象自身可枚举属性名称的数组。\n16. Object.preventExtensions() //防止对象的任何扩展。\n17. Object.seal() //防止其他代码删除对象的属性。\n18. Object.setPrototypeOf() **_ES2015_** //设置对象的原型（即内部 [[Prototype]] 属性）。\n19. Object.values() //返回给定对象自身可枚举值的数组。\n\n## Object 实例和 Object 原型对象\n\n> JavaScript 中的所有对象都来自 Object；所有对象从 Object.prototype 继承方法和属性，尽管它们可能被覆盖。\n\n```javascript\nObject.prototype.constructor; //特定的函数，用于创建一个对象的原型。\n```\n\n## 实例方法\n\n1. Object.prototype.hasOwnProperty() //返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。\n2. Object.prototype.isPrototypeOf() //返回一个布尔值，表示指定的对象是否在本对象的原型链中。\n3. Object.prototype.propertyIsEnumerable() //判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。\n4. Object.prototype.toLocaleString() //直接调用 toString()方法。\n5. Object.prototype.toString() //返回对象的字符串表示。\n6. Object.prototype.valueOf() //返回指定对象的原始值。\n\n## 创建对象\n\n```javascript\nconst person = {};\ntypeof person; //object\n```\n\n### 使用 Object 全局函数\n\n```javascript\nconst person = Object();\ntypeof person; //object\n```\n\n### 使用 Object 构造器\n\n```javascript\nconst person = new Object();\ntypeof person; //object\n```\n\n### 使用 Object.create()\n\n```javascript\nconst car = Object.create();\n```\n\n```javascript\nconst person = {\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n};\n\nconst person = Object({\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n});\n\nconst person = new Object({\n  age: 36,\n  name: 'funny',\n  speak: () => {\n    //speak\n  },\n});\n```\n\n### Object.assign\n\n```javascript\nconst copied = Object.assign({}, target1, target2, ...target);\n```\n\n> Object.assign-将一个或多个对象的所有可枚举属性复制到另一个对象中。浅拷贝，复制对象引用而非对象本身。\n\n```javascript\nconst original = {\n  name: 'Fiesta',\n  car: {\n    color: 'blue',\n  },\n};\nconst copied = Object.assign({}, original);\n\noriginal.name = 'Focus';\noriginal.car.color = 'yellow';\n\ncopied.name; //Fiesta\ncopied.car.color; //yellow\n```\n\n### Object.create\n\n```javascript\nconst newObject = Object.create(prototype);\n\nconst newObject = Object.create(prototype, newProperties);\n```\n\n> 使用指定原型创建新的对象，可以指定第二个参数来向对象添加新属性\n\n```javascript\nconst animal = {};\nconst dog = Object.create(animal);\n\nconst animal = {};\nconst dog = Object.create(animal, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n### Object.defineProperty\n\n> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象\n\n```javascript\nconst dog = {};\nObject.defineProperty(dog, 'breed', {\n  value: 'Siberian Husky',\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n扩展：[vue 原理之-神奇的 Object.defineProperty](\"https://zhuanlan.zhihu.com/p/29066270\")\n\n### Object.defineProperties\n\n> 直接在一个对象上定义新的属性或修改现有属性，并返回该对象\n\n```javascript\nconst dog = {};\nObject.defineProperties(dog, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nconsole.log(dog.breed); //'Siberian Husky'\n```\n\n### Object.entries()\n\n> ES2017,返回自身可枚举属性的键值对数组\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nObject.entries(person); // [['name', 'Fred'], ['age', 87]]\n\nconst people = ['Fred', 'Tony'];\nObject.entries(people); // [['0', 'Fred'], ['1', 'Tony']]\n```\n\n### Object.freeze()\n\n> 冻结对象，冻结后不能再添加或修改\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.freeze(dog);\n\nObject.isFrozen(dog); //true\nObject.isFrozen(myDog); //true\ndog === myDog; //true\n\ndog.name = 'Roger'; //TypeError: 无法添加name属性，dog是不可扩展的\n```\n\n### Object.getOwnPropertyDescriptor()\n\n> 返回自由属性描述符\n\n```javascript\nconst dog = {};\nObject.defineProperties(dog, {\n  breed: {\n    value: 'Siberian Husky',\n  },\n});\nObject.getOwnPropertyDescriptor(dog, 'breed');\n/*\n{\n  value: 'Siberian Husky',\n  writable: false,\n  enumerable: false,\n  configurable: false\n}\n*/\n```\n\n### Object.getOwnPropertyNames()\n\n> 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\ndog.name = 'Roger';\n\nObject.getOwnPropertyNames(dog); //[ 'breed', 'name' ]\n```\n\n### Object.getOwnPropertySymbols()\n\n> 返回一个给定对象自身的所有 Symbol 属性的数\n\n```javascript\nconst dog = {};\nconst r = Symbol('Roger');\nconst s = Symbol('Syd');\ndog[r] = {\n  name: 'Roger',\n  age: 6,\n};\ndog[s] = {\n  name: 'Syd',\n  age: 5,\n};\n\nObject.getOwnPropertySymbols(dog); //[ Symbol(Roger), Symbol(Syd) ]\n```\n\n### Object.getPrototypeOf()\n\n> 返回指定对象的原型（内部[[Prototype]]属性的\n\n```javascript\nconst animal = {};\nconst dog = Object.create(animal);\nconst prot = Object.getPrototypeOf(dog);\n\nanimal === prot; //true\n\n//如果对象没有原型，将返回null\nObject.prototype; //{}\nObject.getPrototypeOf(Object.prototype); //null\n```\n\n### Object.is()\n\n> 判断两个值是否相等\n\n- 两个值都是 undefined\n- 两个值都是 null\n- 两个值都是 true 或者都是 false\n- 两个值是由相同个数的字符按照相同的顺序组成的字符串\n- 两个值指向同一个对象\n- 两个值都是数字并且\n  - 都是正零 +0\n  - 都是负零 -0\n  - 都是 NaN\n  - 都是除零和 NaN 外的其它同一个数字\n\n```javascript\nObject.is(a, b);\n```\n\n### Object.isExtensible()\n\n> 判断一个对象是否是可扩展的，返回布尔值。任何对象都是可扩展，除非使用了 Object.freeze()、Object.seal()、Object.preventExtensions()\n\n### Object.isFrozen()\n\n> 判断一个对象是否被冻结，返回布尔值\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.freeze(dog);\nObject.isFrozen(dog); //true\nObject.isFrozen(myDog); //true\ndog === myDog; //true\n```\n\n### Object.isSealed()\n\n> 判断一个对象是否被密封，返回布尔值\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nconst myDog = Object.seal(dog);\nObject.isSealed(dog); //true\nObject.isSealed(myDog); //true\ndog === myDog; //true\n```\n\n### Object.keys()\n\n> 返回对象的自身可枚举属性组成的数组\n\n```javascript\nconst car = {\n  color: 'Blue',\n  brand: 'Ford',\n  model: 'Fiesta',\n};\n\nObject.keys(car); //[ 'color', 'brand', 'model' ]\n```\n\n### Object.preventExtensions()\n\n> 阻止对象扩展，但可以删除属性\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nObject.preventExtensions(dog);\n\ndog.name = 'Roger'; //TypeError: Cannot add property name, object is not extensible\n\ndelete dog.name;\ndog; //{ breed: 'Siberian Husky' }\n```\n\n### Object.seal()\n\n> 与 Object.freeze（）类似，但不会使属性不可写。仅阻止添加或删除属性。与 Object.preventExtensions（）类似，但也不允许删除属性：\n\n```javascript\nconst dog = {};\ndog.breed = 'Siberian Husky';\nObject.seal(dog);\ndog.breed = 'Pug';\ndog.name = 'Roger'; //TypeError: Cannot add property name, object is not extensible\n```\n\n### Object.values()\n\n> 对象自身的所有可枚举属性值的数组\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nObject.values(person); // ['Fred', 87]\n\nconst people = ['Fred', 'Tony'];\nObject.values(people); // ['Fred', 'Tony']\n```\n\n### Object.hasOwnProperty()\n\n> 判断对象自身是否有某个值，返回布尔值\n\n```javascript\nconst person = { name: 'Fred', age: 87 };\nperson.hasOwnProperty('name'); //true\nperson.hasOwnProperty('job'); //false\n```\n\n### Object.isPrototypeOf()\n\n> 测试一个对象是否存在于另一个对象的原型链上\n\n```javascript\nconst Animal = {\n  isAnimal: true,\n};\n\nconst Mammal = Object.create(Animal);\nMammal.isMammal = true;\n\nAnimal.isPrototypeOf(Mammal); //true\n\nconst dog = Object.create(Animal);\nObject.setPrototypeOf(dog, Mammal);\n\nAnimal.isPrototypeOf(dog); //true\nMammal.isPrototypeOf(dog); //true\n```\n\n### Object.propertyIsEnumerable()\n\n> 判断对象的属性是否可枚举，返回布尔值\n\n```javascript\nconst person = { name: 'Fred' };\n\nObject.defineProperty(person, 'age', {\n  value: 87,\n  enumerable: false,\n});\n\nperson.propertyIsEnumerable('name'); //true\nperson.propertyIsEnumerable('age'); //false\n```\n\n### Object.toLocaleString()\n\n```javascript\nconst person = { name: 'Fred' };\nperson.toLocaleString(); //[object Object]\n```\n\n### Object.toString()\n\n```javascript\nconst person = { name: 'Fred' };\nperson.toString(); //[object Object]\n```\n\n### Object.valueOf()\n\n> 返回指定对象的原始值\n\n```javascript\nconst person = { name: 'Fred' };\nperson.valueOf(); //{ name: 'Fred' }\n```\n","slug":"javascript/base/Object"},{"data":{"date":"May 10, 2018","title":"Boolean","tags":["javascript"],"fromNow":"4 years ago"},"content":"\nBoolean 有两个值 true/false。\n\n| 数据类型  | 转换为 true 的值 | 转换为 false 的值 |\n| --------- | ---------------- | ----------------- |\n| Boolean   | true             | false             |\n| String    | 任意飞空字符串   | 空字符串          |\n| Number    | 任何非零值       | 0 和 NaN          |\n| Object    | 任何对象         | null              |\n| Undefined |                  | undefined         |\n","slug":"javascript/base/Boolean"},{"data":{"date":"September 16, 2021","title":"Basic Types","tags":["go"],"fromNow":"3 months ago"},"content":"\n## 布尔值\n\n布尔值包括 `true` 和 `false`。\n\n```go\nvar b bool = true\nfmt.Printf(\"b is: '%v'\\n\", b)\n//b = false\nfmt.Printf(\"b is: '%v'\\n\", b)\nvar b2 bool\nfmt.Printf(\"zero value of bool is: '%v'\\n\", b2)\n//b is: 'true'\n//b is: 'false'\n//zero value of bool is: 'false'\n```\n\n布尔值的大小是 1 字节\n\n```go\nb := true\nfmt.Printf(\"size of bool is: %d\\n\", unsafe.Sizeof(b))\n//size of bool is: 1\n```\n\n## 整型\n\nGo 语言支持的整数类型有 `int`、`uint`、`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`。\n\n## 浮点型\n\nGo 语言支持的浮点数类型有 `float32`、`float64`。\n\n## 字符型\n\nGo 语言支持的字符型 `byte`、`rune`，`byte`是一个字节，`rune`是一个代表一个字符的整数。\n\n## 字符串\n\nGo 中的 String 是一个不变的字节序列(8 位字节值) ，这与 Python、 c # 、 Java 或 Swift 等语言中的 Unicode 字符串不同。字符串类型的零值为空字符串。\n\n```go\nvar s string // empty string \"\"\n\ts1 := \"string\\nliteral\\nwith\\tescape characters\\n\"\n\ts2 := `raw string literal\nwhich doesnt't recgonize escape characters like \\n\n`\n\tfmt.Printf(\"sum of strings\\n'%s'\\n\", s+s1+s2)\nsum of strings\n'string\nliteral\nwith\tescape characters\nraw string literal\nwhich doesnt‘t recgonize escape characters like'\n```\n\n## 常量\n\nGo 支持字符、字符串、布尔值和数值的常量。\n\n```go\nconst (\n\ti  int = 32       // int constant\n\ts      = \"string\" // string constant\n\ti2     = 33       // untyped number constant\n)\n\nvar (\n\t// values that are not read-only (like slices or maps or structs) cannot be\n\t// constants\n\t// we can declare them as top-level variables\n\tb = []byte{3, 4} // this could not be a constant\n)\n```\n","slug":"go/基本数据类型"},{"data":{"date":"November 26, 2021","title":"Lists","tags":["python"],"description":"列表（List）是 python 的基本类型","fromNow":"19 days ago"},"content":"\n## 创建列表\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnums = [1, 2, 3]\n```\n\n也可以使用其他方法`split()`创建\n\n```python\nline = 'Hello World!'\nrow = line.split(' ')\nrow # ['Hello', 'World!']\n```\n\n## 列表操作\n\n```python\nnames.append('Adam') # 在末尾添加元素\nnames.insert(1, 'Jack') # 在指定位置添加元素\n```\n\n使用`+`连接两个列表\n\n```python\ns=[1,2,3]\nt=[4,5,6]\ns+t # [1,2,3,4,5,6]\n```\n\n列表索引从 0 开始\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnames[0] # Michael\nnames[1] # Bob\nnames[-1] # Tracy\n```\n\n使用索引覆盖元素\n\n```python\nnames[0] = 'Adam' # 修改第一个元素\nnames # ['Adam', 'Bob', 'Tracy']\n```\n\n使用`len`获取列表长度\n\n```python\nlen(names) # 3\n```\n\n使用`in`判断元素是否在列表中\n\n```python\n'Adam' in names # True\n'manon' in names # False\n```\n\n## 列表的循环\n\n使用`for`循环遍历列表\n\n```python\nfor name in names:\n    print(name)\n```\n\n查找索引值\n\n```python\nnames.index('Bob') # 1\n```\n\n## 移除元素\n\n使用`del`或`remove`删除元素\n\n```python\nnames.remove('Bob') # 删除第一个 Bob\ndel names[0] # 删除第一个元素\n```\n\n## 列表的排序\n\n使用`sort`对列表进行排序\n\n```python\ns = [10, 1, 7, 3]\ns.sort()                    # [1, 3, 7, 10]\n\n# Reverse order\ns = [10, 1, 7, 3]\ns.sort(reverse=True)        # [10, 7, 3, 1]\n\n# It works with any ordered data\ns = ['foo', 'bar', 'spam']\ns.sort()                    # ['bar', 'foo', 'spam']\n```\n\n使用`sorted`创建新的列表，不会修改原列表\n\n```python\nt = sorted(s)\n```\n","slug":"python/1.4-list"}]},"__N_SSG":true}