{"pageProps":{"data":{"date":"October 26, 2021","title":"Battery Api","tags":["javascript"],"description":"Battery Api提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件","fromNow":"2 months ago"},"content":{"compiledSource":"var h=Object.defineProperty,y=Object.defineProperties;var p=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,g=Object.prototype.propertyIsEnumerable;var c=(e,t,a)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,r=(e,t)=>{for(var a in t||(t={}))i.call(t,a)&&c(e,a,t[a]);if(o)for(var a of o(t))g.call(t,a)&&c(e,a,t[a]);return e},l=(e,t)=>y(e,p(t));var s=(e,t)=>{var a={};for(var n in e)i.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&o)for(var n of o(e))t.indexOf(n)<0&&g.call(e,n)&&(a[n]=e[n]);return a};const makeShortcode=e=>function(a){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",r({},a))},CanIUse=makeShortcode(\"CanIUse\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=s(n,[\"components\"]);return mdx(MDXLayout,l(r(r({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Battery Api\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"\\u63D0\\u4F9B\\u4E86\\u6709\\u5173\\u7CFB\\u7EDF\\u5145\\u7535\\u7EA7\\u522B\\u7684\\u4FE1\\u606F\\u5E76\\u63D0\\u4F9B\\u4E86\\u901A\\u8FC7\\u7535\\u6C60\\u7B49\\u7EA7\\u6216\\u8005\\u5145\\u7535\\u72B6\\u6001\\u7684\\u6539\\u53D8\\u63D0\\u9192\\u7528\\u6237\\u7684\\u4E8B\\u4EF6\\uFF0CBattery Status API \\u5411 window.navigator \\u6269\\u5C55\\u4E86\\u4E00\\u4E2A navigator.getBattery \\u65B9\\u6CD5\\uFF0C\\u5176\\u8FD4\\u56DE\\u4E86\\u4E00\\u4E2A battery promise, \\u5B8C\\u6210\\u540E\\u4F20\\u9012\\u4E00\\u4E2A BatteryManager \\u5BF9\\u8C61\\uFF0C\\u5E76\\u63D0\\u4F9B\\u4E86\\u4E00\\u4E9B\\u65B0\\u7684\\u53EF\\u4EE5\\u64CD\\u4F5C\\u7535\\u6C60\\u72B6\\u6001\\u7684\\u4E8B\\u4EF6\\u3002\")),mdx(CanIUse,{tag:\"will-change\",mdxType:\"CanIUse\"}),mdx(\"h2\",null,\"\\u65B9\\u6CD5\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"chargingchange\"),mdx(\"li\",{parentName:\"ul\"},\"levelchange\"),mdx(\"li\",{parentName:\"ul\"},\"chargingtimechange\"),mdx(\"li\",{parentName:\"ul\"},\"dischargingtimechange\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-javascript\"}),`navigator.getBattery().then(function (battery) {\n  console.log('Battery charging? ' + (battery.charging ? 'Yes' : 'No'));\n  console.log('Battery level: ' + battery.level * 100 + '%');\n  console.log('Battery charging time: ' + battery.chargingTime + ' seconds');\n  console.log(\n    'Battery discharging time: ' + battery.dischargingTime + ' seconds'\n  );\n\n  battery.addEventListener('chargingchange', function () {\n    console.log('Battery charging? ' + (battery.charging ? 'Yes' : 'No'));\n  });\n\n  battery.addEventListener('levelchange', function () {\n    console.log('Battery level: ' + battery.level * 100 + '%');\n  });\n\n  battery.addEventListener('chargingtimechange', function () {\n    console.log('Battery charging time: ' + battery.chargingTime + ' seconds');\n  });\n\n  battery.addEventListener('dischargingtimechange', function () {\n    console.log(\n      'Battery discharging time: ' + battery.dischargingTime + ' seconds'\n    );\n  });\n});\n`)),mdx(\"p\",null,mdx(\"img\",r({parentName:\"p\"},{src:\"https://cdn.jsdelivr.net/gh/funnypan/pics@master/uPic/r63S43.png\",alt:\"r63S43\"}))))}MDXContent.isMDXComponent=!0;\n","scope":{"date":"October 26, 2021","title":"Battery Api","tags":["javascript"],"description":"Battery Api提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件","fromNow":"2 months ago"}},"randomPost":[{"data":{"date":"May 19, 2020","title":"作用域","tags":["javascript"],"fromNow":"2 years ago"},"content":"\n作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期\n","slug":"javascript/advance/作用域"},{"data":{"date":"December 21, 2020","title":"Docker入门","tags":["docker"],"description":"Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。","fromNow":"a year ago"},"content":"\n## 简介\n\nDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n## 应用场景\n\n- Web 应用的自动化打包和发布。\n- 自动化测试和持续集成、发布。\n- 在服务型环境中部署和调整数据库或其他的后台应用。\n- 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。\n\n## 优点\n\n- 快速，一致地交付您的应用程序\n- 响应式部署和扩展\n- 在同一硬件上运行更多工作负载\n\n## 目录\n\n- [x] [Docker 镜像](./Docker镜像)\n- [x] [Docker 容器](./Docker容器)\n- [x] [Dockerfiles](./Dockerfiles)\n- [x] [Docker 更新容器](./Docker更新容器)\n- [x] [Docker 更新镜像](./Docker更新镜像)\n- [ ] [How to access files outside a Docker image]()\n- [ ] [Sharing Docker Images on Docker Hub]()\n- [ ] [Working with Docker Images from the command line]()\n- [ ] [Working with Docker Containers from the command line]()\n- [ ] [What to do if a Docker container immediately exits]()\n- [ ] [Create a simple Node.js Hello World Docker Container from scratch]()\n- [ ] [Using Docker Desktop to manage a Container]()\n- [ ] [First steps with Docker after the installation]()\n- [x] [Macos 安装 Docker](./Macos安装Docker)\n","slug":"docker/index"},{"data":{"date":"December 10, 2021","title":"Formatting","tags":["python"],"description":"输出格式化","fromNow":"5 days ago"},"content":"\n当输出数据时，我们希望能够按照一定的格式输出，这个时候就可以使用 format()函数。比如：\n\n```python\n      Name      Shares        Price\n----------  ----------  -----------\n        AA         100        32.20\n       IBM          50        91.10\n       CAT         150        83.44\n      MSFT         200        51.23\n        GE          95        40.37\n      MSFT          50        65.10\n       IBM         100        70.44\n```\n\n## 字符输出格式化\n\n在`python 3.6+`使用`f-strings`格式化字符串，如下：\n\n```python\nname = 'IBM'\nshares = 100\nprice = 91.1\nf'{name:>10s} {shares:>10d} {price:>10.2f}'\n#'       IBM        100      91.10'\n\n# 通常配合 print()函数使用，如下：\nprint(f'{name:>10s} {shares:>10d} {price:>10.2f}')\n```\n\n## 格式化代码\n\n格式代码(在`{}`中`:` 之后)类似于 c `printf ()`。常见代码包括:\n\n```python\nd       # 整数\nb       # 十六进制\nx       # 十六进制\nf       # 浮点数\ne       # 指数\ng       # 指数或浮点数\ns       # 字符串\nc       # 字符\n```\n\n常用的修饰符调整字段宽度和十进制精度。这是一个部分列表:\n\n```python\n:>10d   # 宽度为10，十进制精度无限制\n:<10d   # 宽度为10，十进制精度无限制\n:^10d   # 宽度为10，十进制精度无限制\n:0.2f   # 宽度为无限制，十进制精度为2\n```\n\n## 字典格式化\n\n使用`format_map`函数可以将字典中的键和值对应输出，如下：\n\n```python\ns = {\n    'name': 'IBM',\n    'shares': 100,\n    'price': 91.1\n}\n'{name:>10s} {shares:10d} {price:10.2f}'.format_map(s)\n#'       IBM        100      91.10'\n```\n\n## format()函数\n\n```python\n'{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1)\n#'       IBM        100      91.10'\n'{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1)\n#'       IBM        100      91.10'\n```\n\n## C 语言格式化\n\n使用`%`可以格式化字符串，如下：\n\n```python\n'The value is %d' % 3\n#'The value is 3'\n'%5d %-5d %10d' % (3,4,5)\n#'    3 4              5'\n'%0.2f' % (3.1415926,)\n#'3.14'\n```\n","slug":"python/2.3-formatting"},{"data":{"date":"November 26, 2021","title":"Lists","tags":["python"],"description":"列表（List）是 python 的基本类型","fromNow":"19 days ago"},"content":"\n## 创建列表\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnums = [1, 2, 3]\n```\n\n也可以使用其他方法`split()`创建\n\n```python\nline = 'Hello World!'\nrow = line.split(' ')\nrow # ['Hello', 'World!']\n```\n\n## 列表操作\n\n```python\nnames.append('Adam') # 在末尾添加元素\nnames.insert(1, 'Jack') # 在指定位置添加元素\n```\n\n使用`+`连接两个列表\n\n```python\ns=[1,2,3]\nt=[4,5,6]\ns+t # [1,2,3,4,5,6]\n```\n\n列表索引从 0 开始\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nnames[0] # Michael\nnames[1] # Bob\nnames[-1] # Tracy\n```\n\n使用索引覆盖元素\n\n```python\nnames[0] = 'Adam' # 修改第一个元素\nnames # ['Adam', 'Bob', 'Tracy']\n```\n\n使用`len`获取列表长度\n\n```python\nlen(names) # 3\n```\n\n使用`in`判断元素是否在列表中\n\n```python\n'Adam' in names # True\n'manon' in names # False\n```\n\n## 列表的循环\n\n使用`for`循环遍历列表\n\n```python\nfor name in names:\n    print(name)\n```\n\n查找索引值\n\n```python\nnames.index('Bob') # 1\n```\n\n## 移除元素\n\n使用`del`或`remove`删除元素\n\n```python\nnames.remove('Bob') # 删除第一个 Bob\ndel names[0] # 删除第一个元素\n```\n\n## 列表的排序\n\n使用`sort`对列表进行排序\n\n```python\ns = [10, 1, 7, 3]\ns.sort()                    # [1, 3, 7, 10]\n\n# Reverse order\ns = [10, 1, 7, 3]\ns.sort(reverse=True)        # [10, 7, 3, 1]\n\n# It works with any ordered data\ns = ['foo', 'bar', 'spam']\ns.sort()                    # ['bar', 'foo', 'spam']\n```\n\n使用`sorted`创建新的列表，不会修改原列表\n\n```python\nt = sorted(s)\n```\n","slug":"python/1.4-list"},{"data":{"date":"October 28, 2020","title":"Linux命令traceroute","tags":["linux"],"description":"traceroute命令用于显示数据包到主机之间的路径","fromNow":"a year ago"},"content":"\n**traceroute**命令用于显示数据包到主机之间的路径。\n\n> raceroute 命令 用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。\n>\n> 通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。\n>\n> traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其 ip 地址。\n\n## 使用方法\n\n```shell\ntraceroute <host>\n```\n\n## 案例\n\n![1EOlsJ](https://cdn.jsdelivr.net/gh/manonicu/pics@master/uPic/1EOlsJ.png)\n\n## 参数\n\n- -d 使用 Socket 层级的排错功能。\n- -f<存活数值> 设置第一个检测数据包的存活数值 TTL 的大小。\n- -F 设置勿离断位。\n- -g<网关> 设置来源路由网关，最多可设置 8 个。\n- -i<网络界面> 使用指定的网络界面送出数据包。\n- -I 使用 ICMP 回应取代 UDP 资料信息。\n- -m<存活数值> 设置检测数据包的最大存活数值 TTL 的大小。\n- -n 直接使用 IP 地址而非主机名称。\n- -p<通信端口> 设置 UDP 传输协议的通信端口。\n- -r 忽略普通的 Routing Table，直接将数据包送到远端主机上。\n- -s<来源地址> 设置本地主机送出数据包的 IP 地址。\n- -t<服务类型> 设置检测数据包的 TOS 数值。\n- -v 详细显示指令的执行过程。\n- -w<超时秒数> 设置等待远端主机回报的时间。\n- -x 开启或关闭数据包的正确性检验。\n\n**traceroute**命令可在 Linux、macOS、WSL 和任何 UNIX 环境下运行\n","slug":"linux/Linux命令-traceroute"},{"data":{"date":"May 21, 2020","title":"Go-HelloWorld","tags":["go"],"fromNow":"2 years ago"},"content":"\n## 搭建开发环境\n\n让我们创建一个目录，在该目录中编写我们的 hello world 程序。打开终端并运行以下命令。\n\n```shell\nmkdir ~/Documents/learngo/\n```\n\n上面的命令将 learngo 在当前用户的 Documents 目录中创建一个名为目录。\n\n### 你好，世界\n\n使用您喜欢的文本编辑器 main.go 在 learngo 目录中创建一个名为以下内容的文件。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello World\")\n}\n```\n\n按照 Go 中的约定，将包含 main 函数的文件命名为 main.go。\n\n### 运行程序\n\n1. go install\n\n```shell\ncd ~/Documents/learngo/\ngo install\n#此命令将编译程序并将编译好的二进制文件复制到~/go/bin内\nls -al ~/go/bin/\n\n~/go/bin/learngo\n#输出hello world\n```\n\n2. go build\n\n```shell\ncd ~/Documents/learngo/\ngo build\n#上面的命令将learngo在当前目录中创建一个二进制文件。ls -al将显示learngo已创建一个名为的文件。\n./learngo\n#输出Hello World\n```\n\n3. go run\n\ncd ~/Documents/learngo/在终端中键入命令以将当前目录更改为 learngo。\n\n```shell\ngo run main.go\nHello World\n#go run和go build/go install命令之间的细微差别是，go run需要.go文件名作为参数。\n```\n\ngo run 工作原理非常相似 go build。无需将程序编译并安装到当前目录，而是将文件编译到一个临时位置并从该位置运行文件。如果您想知道 go run 将文件编译到的位置，请 go run 使用--work 参数运行。\n\n```shell\ngo run --work main.go\n```\n\n4. go playground\n\n<Gist gistLink=\"Manonicu/ef552d29300ffb0cd311d9cc8828bc6e\" />\n\n我们将简要讨论该程序的每一行的作用。\n\n- package main - 每个 go 文件必须以 package name 开始。\n- import \"fmt\" - import 语句用于导入其他软件\n\n  包\n\n- func main（）- func 关键字标记函数的开始。\n- fmt.Println（\"H​​ello World\"）\n","slug":"go/第一个Go程序"}]},"__N_SSG":true}